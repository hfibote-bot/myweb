<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>èºçº¿ç®¡(å¤šå±‚èºæ—‹)ç£åœºå¯äº¤äº’è®¡ç®—å™¨ï¼ˆçº¯HTMLï¼‰</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --panel2:#0c132b;
      --text:#e8ecff;
      --muted:#b6c2ff;
      --border:rgba(255,255,255,.12);
      --accent:#7aa2ff;
      --danger:#ff6b6b;
      --ok:#2fe37a;
    }
    html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";}
    body{background:var(--bg); color:var(--text);}
    .wrap{display:flex; height:100vh; overflow:hidden;}
    .left{
      width:440px; min-width:320px; max-width:640px;
      border-right:1px solid var(--border);
      background:linear-gradient(180deg, var(--panel), var(--panel2));
      padding:14px 14px 10px 14px;
      overflow:auto;
    }
    .right{flex:1; min-width:0; background:var(--bg);}
    h1{font-size:16px; margin:0 0 10px 0; font-weight:950;}
    .hint{font-size:12px; color:var(--muted); line-height:1.50; margin-bottom:10px;}
    .card{
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      margin:10px 0;
      background:rgba(255,255,255,.03);
    }
    .card h2{font-size:13px; margin:0 0 8px 0; font-weight:950; color:var(--text);}
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px 10px;
      align-items:end;
    }
    label{display:block; font-size:12px; color:var(--muted); margin:0 0 4px 2px;}
    input[type="number"], select{
      width:100%;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.20);
      color:var(--text);
      outline:none;
      box-sizing:border-box;
    }
    input[disabled]{opacity:.55; cursor:not-allowed;}
    input[type="number"]:focus, select:focus{
      border-color:rgba(122,162,255,.7);
      box-shadow:0 0 0 3px rgba(122,162,255,.16);
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn{
      appearance:none; border:1px solid var(--border);
      background:rgba(122,162,255,.16);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:950;
      transition:transform .05s ease;
    }
    .btn:active{transform:translateY(1px);}
    .btn.primary{background:rgba(122,162,255,.28); border-color:rgba(122,162,255,.55);}
    .btn.ghost{background:rgba(255,255,255,.04);}
    .btn.danger{background:rgba(255,107,107,.18); border-color:rgba(255,107,107,.55);}
    .btn:disabled{opacity:.55; cursor:not-allowed;}
    .pill{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .kv{
      display:grid; grid-template-columns: 1fr 1fr;
      gap:8px 10px;
      font-size:12px;
      color:var(--muted);
    }
    .kv b{color:var(--text); font-weight:950;}
    .status{font-size:12px; line-height:1.45; margin-top:8px; color:var(--muted);}
    .status .ok{color:var(--ok); font-weight:950;}
    .status .bad{color:var(--danger); font-weight:950;}
    .chk{
      display:flex; gap:8px; align-items:center;
      font-size:12px; color:var(--muted);
      user-select:none;
      margin:4px 0;
    }
    .chk input{transform:translateY(1px);}
    #plot{width:100%; height:100vh;}
    .small{font-size:12px; color:var(--muted); line-height:1.55;}
    details summary{cursor:pointer; color:var(--text); font-weight:950;}
    details{margin-top:8px;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .divider{height:1px; background:var(--border); margin:10px 0;}
    .badge{
      display:inline-flex;
      padding:6px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      font-size:12px;
      color:var(--muted);
      gap:8px;
      align-items:center;
    }
    .badge b{color:var(--text);}
  </style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <h1>èºçº¿ç®¡ç£åœºï¼ˆçº¯HTMLï¼šç‚¹äº‘/æ–¹å‘/ç£åœºçº¿ï¼‰</h1>
    <div class="hint">
      ä½ ç°åœ¨å¯ä»¥åœ¨â€œç‚¹äº‘â€ä¹‹å¤–ï¼Œç”¨<strong>ç£åœºçº¿ï¼ˆstreamlinesï¼‰</strong>æ¥çœ‹æ–¹å‘ä¸æ‹“æ‰‘ï¼š<br>
      - ç‚¹äº‘ï¼šé¢œè‰²=|B|ï¼ˆæœ€ç›´è§‚çš„â€œå¤§å°â€æ˜¾ç¤ºï¼‰<br>
      - ç£åœºçº¿ï¼šç”¨ç§¯åˆ†å¾—åˆ°çš„â€œè·Ÿéš B å‘é‡â€çš„æ›²çº¿ï¼Œä¾¿äºçœ‹ç»“æ„ï¼›å¯ç”¨æŒ‰é’®â€œä¸€é”®æ›¿æ¢æ‰ç‚¹äº‘â€<br>
      <span class="small">æ³¨æ„ï¼šç£åœºçº¿â€œå¯†åº¦â€ä¸¥æ ¼æ¥è¯´ä¾èµ–ä½ æ€ä¹ˆé€‰èµ·ç‚¹ï¼ˆseedï¼‰ï¼›æœ¬å·¥å…·é»˜è®¤å‡åŒ€æ’­ç§ï¼Œåå®šæ€§å±•ç¤ºã€‚</span>
    </div>

    <div class="card">
      <h2>å‡ ä½•å‚æ•°ï¼ˆå•ä½ï¼šmmï¼‰</h2>
      <div class="grid">
        <div>
          <label>å†…åŠå¾„ R_inï¼ˆ=å†…å¾„/2ï¼‰</label>
          <input type="number" id="inner_radius_mm" value="15" step="0.1" min="0">
        </div>
        <div>
          <label>å¾„å‘å±‚æ•°</label>
          <input type="number" id="n_layers" value="4" step="1" min="1" max="30">
        </div>

        <div>
          <label>æ¯å±‚åŒæ•°</label>
          <input type="number" id="turns_per_layer" value="50" step="1" min="1" max="8000">
        </div>
        <div>
          <label>åŒè· pitch</label>
          <input type="number" id="pitch_mm" value="6" step="0.1" min="0.001">
        </div>

        <div>
          <label>å¯¼ä½“å¤–å¾„ OD</label>
          <input type="number" id="wire_od_mm" value="6" step="0.1" min="0.1">
        </div>
        <div>
          <label>å¯¼ä½“å†…å¾„ IDï¼ˆç©ºå¿ƒæ°´é“ï¼Œä»…æ˜¾ç¤ºï¼‰</label>
          <input type="number" id="wire_id_mm" value="4" step="0.1" min="0">
        </div>

        <div>
          <label>å±‚é—´å¾„å‘é—´éš™ gap_r</label>
          <input type="number" id="gap_radial_mm" value="0.2" step="0.1">
        </div>
        <div>
          <label>æ¯å±‚èµ·å§‹è§’åº¦åç§»ï¼ˆdegï¼‰</label>
          <input type="number" id="layer_phase_deg" value="0" step="1">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <span class="pill">æ¨å¯¼å€¼</span>
      </div>
      <div class="kv" style="margin-top:8px;">
        <div>çº¿åœˆé•¿åº¦ L â‰ˆ <b id="derived_len">-</b></div>
        <div>å¤–åŠå¾„ R_out â‰ˆ <b id="derived_rout">-</b></div>
        <div>æ€»åŒæ•° N = <b id="derived_ntotal">-</b></div>
        <div>å®‰åŒ NI = <b id="derived_ni">-</b></div>
      </div>

      <div class="chk" title="æ˜¾ç¤ºç®¡çŠ¶ç½‘æ ¼æ›´åƒæ°´å†·é“œç®¡ï¼Œä½†æ›´æ…¢">
        <input type="checkbox" id="show_tube" checked>
        <label for="show_tube" style="margin:0;">æ˜¾ç¤ºç®¡çŠ¶å¯¼ä½“ï¼ˆè¾ƒæ…¢ï¼‰</label>
      </div>
      <div class="chk" title="åŠé€æ˜ä¾¿äºçœ‹åˆ°â€œç©ºå¿ƒæ°´é“â€çš„æ„Ÿè§‰">
        <input type="checkbox" id="show_hollow" checked>
        <label for="show_hollow" style="margin:0;">åŠé€æ˜ + æ˜¾ç¤ºå†…å­”ï¼ˆè§†è§‰è¡¨è¾¾ï¼‰</label>
      </div>
    </div>

    <div class="card">
      <h2>ç”µæµä¸æ˜¾ç¤ºæ¨¡å¼</h2>
      <div class="grid">
        <div>
          <label>ç”µæµ Iï¼ˆAï¼‰</label>
          <input type="number" id="current_A" value="64" step="0.1">
        </div>
        <div>
          <label>é¢œè‰²å•ä½</label>
          <select id="field_unit">
            <option value="T">Tesla (T)</option>
            <option value="G" selected>Gauss (G)</option>
          </select>
        </div>
      </div>

      <div class="divider"></div>

      <div class="row">
        <span class="badge">å½“å‰æ˜¾ç¤ºï¼š<b id="mode_badge">ç‚¹äº‘</b></span>
        <button class="btn ghost" id="btn_toggle_mode">ğŸ§² ç£åœºçº¿ / ç‚¹äº‘</button>
        <button class="btn ghost" id="btn_toggle_dir">â†— æ–¹å‘ç®­å¤´</button>
      </div>

      <div class="small" style="margin-top:8px;">
        ä½ è¯´çš„â€œæœ€å¤§å€¼åœ¨è¾¹ä¸Šé è¿‘çº¿åœˆâ€æ˜¯æ­£å¸¸çš„ï¼šé è¿‘ç”µæµå¯¼ä½“å¤„ |B| æ›´å¤§ã€‚å¯¹ helicon è®¾è®¡æ›´æœ‰ç”¨çš„æ˜¯çœ‹ç­‰ç¦»å­ä½“æŸ±é™„è¿‘ï¼ˆå° rï¼‰çš„è½´å‘åœºå¼ºä¸æ¢¯åº¦ã€‚
      </div>
    </div>

    <div class="card">
      <h2>è®¡ç®—åŸŸï¼ˆr ä¸ z åˆ†å¼€è®¾ç½®ï¼‰</h2>

      <div class="chk" title="è‡ªåŠ¨æŠŠè®¡ç®—åŸŸä¸çº¿åœˆå¤–å½¢å…³è”ï¼šåŠå¾„â‰ˆR_out+margin_rï¼Œé•¿åº¦â‰ˆL+2margin_zã€‚margin å…è®¸è´Ÿå€¼ï¼ˆç¼©å°è§†é‡ï¼‰ã€‚">
        <input type="checkbox" id="auto_domain" checked>
        <label for="auto_domain" style="margin:0;"><b>è‡ªåŠ¨è®¡ç®—åŸŸ</b>ï¼ˆâ‰ˆ å¤–åŠå¾„/é•¿åº¦ + marginï¼‰</label>
      </div>

      <div class="grid" style="margin-top:8px;">
        <div>
          <label>å¾„å‘ margin_rï¼ˆmmï¼Œå¯ä¸ºè´Ÿï¼‰</label>
          <input type="number" id="domain_margin_r_mm" value="30" step="1">
        </div>
        <div>
          <label>è½´å‘ margin_zï¼ˆmmï¼Œå¯ä¸ºè´Ÿï¼‰</label>
          <input type="number" id="domain_margin_z_mm" value="30" step="1">
        </div>

        <div>
          <label>é‡‡æ ·åŠå¾„ R_domainï¼ˆmmï¼‰</label>
          <input type="number" id="field_radius_mm" value="60" step="1" min="1">
        </div>
        <div>
          <label>é‡‡æ ·é•¿åº¦ L_domainï¼ˆmmï¼‰</label>
          <input type="number" id="field_length_mm" value="300" step="1" min="1">
        </div>
      </div>

      <div class="grid" style="margin-top:8px;">
        <div>
          <label>æ˜¾ç¤ºé˜ˆå€¼ï¼ˆ0~1ï¼ŒæŒ‰æœ€å¤§å€¼æ¯”ä¾‹ï¼‰</label>
          <input type="number" id="display_min_frac" value="0" step="0.05" min="0" max="0.99">
        </div>
        <div class="small" style="margin-top:18px;">
          ä¾‹ï¼š0.2 åªæ˜¾ç¤º â‰¥ 20%Â·Bmaxï¼ˆè¿‡æ»¤æš—ç‚¹ï¼‰ã€‚è‹¥æƒ³çœ‹è¿œå¤„å¼±åœºï¼Œè¯·è®¾ä¸º 0ã€‚
        </div>
      </div>
    </div>

    <div class="card">
      <h2>ç‚¹äº‘ä¸æ–¹å‘ç®­å¤´å‚æ•°</h2>
      <div class="grid">
        <div>
          <label>ç‚¹äº‘ç‚¹å¤§å°</label>
          <input type="number" id="marker_size" value="3" step="1" min="1" max="12">
        </div>
        <div>
          <label>æ–¹å‘ç®­å¤´é•¿åº¦ï¼ˆmmï¼‰</label>
          <input type="number" id="dir_len_mm" value="8" step="1" min="1">
        </div>
      </div>

      <div class="row" style="margin-top:10px; align-items:flex-start;">
        <div style="flex:1; min-width:170px;">
          <label>ç‚¹äº‘å¯†åº¦ï¼ˆz Ã— r Ã— Î¸ï¼‰</label>
          <div class="row">
            <input type="number" id="pts_nz" value="15" step="1" min="2" style="width:72px">
            <input type="number" id="pts_nr" value="6" step="1" min="2" style="width:72px">
            <input type="number" id="pts_nt" value="12" step="1" min="1" style="width:72px">
          </div>
        </div>
        <div style="flex:1; min-width:170px;">
          <label>æ–¹å‘ç®­å¤´å¯†åº¦ï¼ˆz Ã— r Ã— Î¸ï¼‰</label>
          <div class="row">
            <input type="number" id="dir_nz" value="10" step="1" min="2" style="width:72px">
            <input type="number" id="dir_nr" value="4" step="1" min="2" style="width:72px">
            <input type="number" id="dir_nt" value="8" step="1" min="1" style="width:72px">
          </div>
        </div>
      </div>

      <div class="chk" style="margin-top:8px;">
        <input type="checkbox" id="dir_head" checked>
        <label for="dir_head" style="margin:0;">æ–¹å‘ç®­å¤´å¸¦å¤´éƒ¨</label>
      </div>
    </div>

    <div class="card">
      <h2>ç£åœºçº¿ï¼ˆStreamlinesï¼‰å‚æ•°</h2>
      <div class="small">
        ç£åœºçº¿é€šè¿‡æ•°å€¼ç§¯åˆ† <span class="mono">dğ’™/ds = Â± B/|B|</span> å¾—åˆ°ï¼›ç§¯åˆ†åªåœ¨ä½ è®¾ç½®çš„è®¡ç®—åŸŸå†…è¿›è¡Œã€‚
      </div>

      <div class="grid" style="margin-top:8px;">
        <div>
          <label>æ’­ç§å¹³é¢ z_seedï¼ˆmmï¼‰</label>
          <input type="number" id="seed_z_mm" value="0" step="5">
        </div>
        <div>
          <label>ç§å­åŠå¾„èŒƒå›´ï¼ˆ0~1Ã—R_domainï¼‰</label>
          <input type="number" id="seed_r_max_frac" value="0.9" step="0.05" min="0.05" max="1">
        </div>

        <div>
          <label>å¾„å‘ç§å­æ•° N_r</label>
          <input type="number" id="seed_nr" value="5" step="1" min="1" max="30">
        </div>
        <div>
          <label>è§’å‘ç§å­æ•° N_Î¸</label>
          <input type="number" id="seed_nt" value="10" step="1" min="1" max="60">
        </div>

        <div>
          <label>æ­¥é•¿ dsï¼ˆmmï¼‰</label>
          <input type="number" id="line_step_mm" value="6" step="1" min="1">
        </div>
        <div>
          <label>æœ€å¤§æ­¥æ•°ï¼ˆå•å‘ï¼‰</label>
          <input type="number" id="line_max_steps" value="160" step="10" min="20" max="1000">
        </div>
      </div>

      <div class="small" style="margin-top:8px;">
        è‹¥ä½ æƒ³çœ‹ z è¿œå¤„å¼±åœºï¼šæŠŠ <b>è½´å‘ margin_z</b> è°ƒå¤§ï¼Œå¹¶æŠŠ <b>æ˜¾ç¤ºé˜ˆå€¼</b> è®¾ä¸º 0ï¼›ç£åœºçº¿ä¼šè‡ªç„¶å»¶ä¼¸åˆ°æ›´è¿œçš„ zã€‚
      </div>
    </div>

    <div class="card">
      <h2>è®¡ç®—ç²¾åº¦/æ€§èƒ½</h2>
      <details>
        <summary>å±•å¼€</summary>
        <div style="margin-top:10px;">
          <div class="grid">
            <div>
              <label>å¯è§†åŒ–ï¼šæ¯åŒç‚¹æ•°</label>
              <input type="number" id="pts_per_turn_vis" value="18" step="1" min="6" max="80">
            </div>
            <div>
              <label>ç£åœºç§¯åˆ†ï¼šæ¯åŒåˆ†æ®µæ•°</label>
              <input type="number" id="seg_per_turn_field" value="40" step="5" min="10" max="240">
            </div>
            <div>
              <label>ç®¡çŠ¶å¯¼ä½“ï¼šåœ†å‘¨åˆ†æ®µ</label>
              <input type="number" id="tube_sides" value="12" step="1" min="6" max="36">
            </div>
            <div>
              <label>æ•°å€¼ç¨³å®š epsilonï¼ˆmï¼‰</label>
              <input type="number" id="epsilon_m" value="1e-6" step="1e-6" min="1e-9">
            </div>
          </div>
          <div class="small" style="margin-top:8px;">
            ç£åœºçº¿æ¨¡å¼å¾ˆåƒè®¡ç®—ï¼šæ¯ä¸€æ­¥è¦ç®—ä¸€æ¬¡ Bã€‚è‹¥å¡é¡¿ï¼Œä¼˜å…ˆé™ä½ï¼š<span class="mono">seg_per_turn_field</span>ã€ç§å­æ•°ã€æœ€å¤§æ­¥æ•°ã€‚
          </div>
        </div>
      </details>
    </div>

    <div class="card">
      <h2>è¿è¡Œä¸ç»“æœ</h2>
      <div class="row">
        <button class="btn primary" id="btn_update">é‡æ–°è®¡ç®— / æ›´æ–°å›¾åƒ</button>
        <button class="btn danger" id="btn_reset">æ¢å¤é»˜è®¤å‚æ•°</button>
      </div>

      <div class="status" id="status">çŠ¶æ€ï¼šç­‰å¾…è®¡ç®—â€¦</div>

      <div class="card" style="margin-top:10px;">
        <h2>ä¸­å¿ƒç£åœºï¼ˆr=0,z=0ï¼‰</h2>
        <div class="kv">
          <div>Bx = <b id="bx0">-</b></div>
          <div>By = <b id="by0">-</b></div>
          <div>Bz = <b id="bz0">-</b></div>
          <div>|B| = <b id="b0">-</b></div>
        </div>

        <div class="divider"></div>

        <div class="small">
          <b>è½´çº¿ä¸Šæœ€å¤§å€¼æ£€æŸ¥ï¼ˆåªåœ¨ r=0 æœç´¢ï¼‰</b><br>
          è½´çº¿ä¸Šæœ€å¤§ |B| å‡ºç°åœ¨ z = <b id="axis_zmax">-</b>ï¼Œå€¼ = <b id="axis_bmax">-</b><br>
        </div>

        <div class="divider"></div>

        <div class="small">
          å¯¹ç…§ï¼ˆsanity-checkï¼‰ï¼š<br>
          <span class="mono">B_long â‰ˆ Î¼0Â·(N/L)Â·I</span>ï¼ˆé•¿èºçº¿ç®¡è¿‘ä¼¼ï¼‰<br>
          <span class="mono">B_finite_sheet</span>ï¼ˆæœ‰é™é•¿åº¦è–„ç”µæµç‰‡è¿‘ä¼¼ï¼‰
          <div style="margin-top:6px;">
            <span class="mono">B_long â‰ˆ </span><b id="b_long">-</b>&nbsp;&nbsp;
            <span class="mono">B_finite_sheet â‰ˆ </span><b id="b_sheet">-</b>
          </div>
        </div>
      </div>

      <details open>
        <summary>åŸç†ä¸æ³¨æ„äº‹é¡¹ï¼ˆç®€ç‰ˆï¼‰</summary>
        <div class="small" style="margin-top:10px;">
          - ä½¿ç”¨ Biotâ€“Savartï¼š<span class="mono">B = (Î¼0 I/4Ï€) Î£ (dl Ã— r)/|r|^3</span>ï¼ˆç¦»æ•£çº¿æ®µå åŠ ï¼‰ã€‚<br>
          - çº¿åœˆç”¨çœŸå®èºæ—‹ä¸­å¿ƒçº¿ï¼›å¯¼ä½“ ID ä»…ç”¨äºâ€œç©ºå¿ƒæ°´å†·â€è§†è§‰è¡¨è¾¾ã€‚<br>
          - <b>å…¨ç©ºé—´æœ€å¤§ |B| é€šå¸¸åœ¨é è¿‘å¯¼ä½“å¤„</b>ï¼Œè¿™ä¸ä½ çœ‹åˆ°çš„â€œè¾¹ä¸Šæœ€å¤§â€ä¸€è‡´ã€‚å¯¹ heliconï¼Œå»ºè®®æŠŠè®¡ç®—åŸŸåŠå¾„ç¼©åˆ°ç­‰ç¦»å­ä½“åŠå¾„é™„è¿‘å¹¶å…³æ³¨è½´å‘ã€‚<br>
          - è‹¥ä½ è¦çœ‹ z è¿œå¤„å¼±åœºï¼šåŠ å¤§ <b>margin_z</b>ï¼Œå¹¶æŠŠ <b>æ˜¾ç¤ºé˜ˆå€¼=0</b>ã€‚<br>
        </div>
      </details>
    </div>
  </div>

  <div class="right">
    <div id="plot"></div>
  </div>
</div>

<script>
/** ===================== åŸºç¡€å·¥å…· ===================== */
function toNumber(id){ return Number(document.getElementById(id).value); }
function setText(id, txt){ document.getElementById(id).textContent = txt; }
function fmtB(valTesla, unitSel){
  if (!isFinite(valTesla)) return "NaN";
  if (unitSel === "G") return (valTesla*1e4).toFixed(3) + " G";
  return valTesla.toFixed(6) + " T";
}
function nowMs(){ return performance.now(); }

/** ===================== Viridis ç®€æ˜“æ’å€¼ï¼ˆç”¨äºçº¿æ®µåˆ†ç®±ç€è‰²ï¼‰ ===================== */
const VIRIDIS = [
  [0.0,   "#440154"],
  [0.111, "#482878"],
  [0.222, "#3e4989"],
  [0.333, "#31688e"],
  [0.444, "#26828e"],
  [0.555, "#1f9e89"],
  [0.666, "#35b779"],
  [0.777, "#6ece58"],
  [0.888, "#b5de2b"],
  [1.0,   "#fde725"],
];
function hexToRgb(hex){
  const h = hex.replace("#","");
  const v = parseInt(h,16);
  return [(v>>16)&255, (v>>8)&255, v&255];
}
function lerp(a,b,t){ return a + (b-a)*t; }
function viridisRgb(t){
  t = Math.max(0, Math.min(1, t));
  for (let i=0; i<VIRIDIS.length-1; i++){
    const a = VIRIDIS[i], b = VIRIDIS[i+1];
    if (t >= a[0] && t <= b[0]){
      const tt = (t - a[0]) / (b[0]-a[0] + 1e-12);
      const ra = hexToRgb(a[1]), rb = hexToRgb(b[1]);
      const r = Math.round(lerp(ra[0], rb[0], tt));
      const g = Math.round(lerp(ra[1], rb[1], tt));
      const bb = Math.round(lerp(ra[2], rb[2], tt));
      return [r,g,bb];
    }
  }
  return hexToRgb(VIRIDIS[VIRIDIS.length-1][1]);
}
function viridisRgba(t, alpha){
  const rgb = viridisRgb(t);
  return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${alpha})`;
}

/** ===================== çŠ¶æ€ ===================== */
let state = {
  showDirs: true,
  visMode: "points", // "points" or "lines"
};

/** ===================== å‚æ•°è¯»å–ä¸æ¨å¯¼ ===================== */
function derivedGeometry(p){
  const Lmm = p.turns_per_layer * p.pitch_mm;
  const Routmm = p.inner_radius_mm + p.wire_od_mm + (p.n_layers-1)*(p.wire_od_mm + p.gap_radial_mm);
  const Ntotal = p.n_layers * p.turns_per_layer;
  return {Lmm, Routmm, Ntotal};
}

function readParams(){
  const p = {
    inner_radius_mm: toNumber("inner_radius_mm"),
    n_layers: Math.round(toNumber("n_layers")),
    turns_per_layer: Math.round(toNumber("turns_per_layer")),
    pitch_mm: toNumber("pitch_mm"),
    wire_od_mm: toNumber("wire_od_mm"),
    wire_id_mm: toNumber("wire_id_mm"),
    gap_radial_mm: toNumber("gap_radial_mm"),
    layer_phase_deg: toNumber("layer_phase_deg"),
    current_A: toNumber("current_A"),
    field_unit: document.getElementById("field_unit").value,

    auto_domain: document.getElementById("auto_domain").checked,
    domain_margin_r_mm: toNumber("domain_margin_r_mm"),
    domain_margin_z_mm: toNumber("domain_margin_z_mm"),
    field_radius_mm: toNumber("field_radius_mm"),
    field_length_mm: toNumber("field_length_mm"),
    display_min_frac: Math.max(0, Math.min(0.99, toNumber("display_min_frac"))),

    marker_size: Math.round(toNumber("marker_size")),
    pts_nz: Math.round(toNumber("pts_nz")),
    pts_nr: Math.round(toNumber("pts_nr")),
    pts_nt: Math.round(toNumber("pts_nt")),

    dir_nz: Math.round(toNumber("dir_nz")),
    dir_nr: Math.round(toNumber("dir_nr")),
    dir_nt: Math.round(toNumber("dir_nt")),
    dir_len_mm: toNumber("dir_len_mm"),
    dir_head: document.getElementById("dir_head").checked,

    // streamline params
    seed_z_mm: toNumber("seed_z_mm"),
    seed_r_max_frac: Math.max(0.05, Math.min(1.0, toNumber("seed_r_max_frac"))),
    seed_nr: Math.round(toNumber("seed_nr")),
    seed_nt: Math.round(toNumber("seed_nt")),
    line_step_mm: toNumber("line_step_mm"),
    line_max_steps: Math.round(toNumber("line_max_steps")),

    // performance/accuracy
    pts_per_turn_vis: Math.round(toNumber("pts_per_turn_vis")),
    seg_per_turn_field: Math.round(toNumber("seg_per_turn_field")),
    tube_sides: Math.round(toNumber("tube_sides")),
    epsilon_m: Number(document.getElementById("epsilon_m").value),

    show_tube: document.getElementById("show_tube").checked,
    show_hollow: document.getElementById("show_hollow").checked,
  };

  const d = derivedGeometry(p);
  if (p.auto_domain){
    p.field_radius_mm = Math.max(1, d.Routmm + p.domain_margin_r_mm);
    p.field_length_mm = Math.max(1, d.Lmm + 2*p.domain_margin_z_mm);
  }
  return p;
}

function validateParams(p){
  const errs = [];
  if (!(p.inner_radius_mm >= 0)) errs.push("å†…åŠå¾„å¿…é¡» â‰¥ 0");
  if (!(p.n_layers >= 1)) errs.push("å±‚æ•°å¿…é¡» â‰¥ 1");
  if (!(p.turns_per_layer >= 1)) errs.push("æ¯å±‚åŒæ•°å¿…é¡» â‰¥ 1");
  if (!(p.pitch_mm > 0)) errs.push("åŒè·å¿…é¡» > 0");
  if (!(p.wire_od_mm > 0)) errs.push("å¤–å¾„å¿…é¡» > 0");
  if (!(p.wire_id_mm >= 0)) errs.push("å†…å¾„å¿…é¡» â‰¥ 0");
  if (p.wire_id_mm >= p.wire_od_mm) errs.push("å†…å¾„å¿…é¡» < å¤–å¾„");
  if (!(p.seg_per_turn_field >= 4)) errs.push("åˆ†æ®µæ•°å¤ªå°");
  if (!(p.pts_per_turn_vis >= 4)) errs.push("å¯è§†åŒ–ç‚¹æ•°å¤ªå°");
  if (!(p.field_radius_mm > 0 && p.field_length_mm > 0)) errs.push("è®¡ç®—åŸŸå¿…é¡» > 0");
  if (!(p.epsilon_m > 0)) errs.push("epsilon å¿…é¡» > 0");
  if (!(p.dir_len_mm > 0)) errs.push("æ–¹å‘ç®­å¤´é•¿åº¦å¿…é¡» > 0");
  if (!(p.marker_size >= 1)) errs.push("ç‚¹å¤§å°å¿…é¡» â‰¥ 1");
  if (!(p.line_step_mm > 0)) errs.push("ç£åœºçº¿æ­¥é•¿å¿…é¡» > 0");
  if (!(p.line_max_steps >= 10)) errs.push("ç£åœºçº¿æœ€å¤§æ­¥æ•°å¤ªå°");
  if (!(p.seed_nr >= 1 && p.seed_nt >= 1)) errs.push("ç£åœºçº¿ç§å­æ•°é‡å¿…é¡» â‰¥ 1");
  return errs;
}

function updateDerivedUI(){
  const pRaw = {
    inner_radius_mm: toNumber("inner_radius_mm"),
    n_layers: Math.round(toNumber("n_layers")),
    turns_per_layer: Math.round(toNumber("turns_per_layer")),
    pitch_mm: toNumber("pitch_mm"),
    wire_od_mm: toNumber("wire_od_mm"),
    gap_radial_mm: toNumber("gap_radial_mm"),
    current_A: toNumber("current_A"),
  };
  const d = derivedGeometry(pRaw);
  setText("derived_len", d.Lmm.toFixed(2) + " mm");
  setText("derived_rout", d.Routmm.toFixed(2) + " mm");
  setText("derived_ntotal", String(d.Ntotal));
  setText("derived_ni", (d.Ntotal * pRaw.current_A).toFixed(2) + " AÂ·turn");

  const auto = document.getElementById("auto_domain").checked;
  const mr = toNumber("domain_margin_r_mm");
  const mz = toNumber("domain_margin_z_mm");
  const fr = document.getElementById("field_radius_mm");
  const fl = document.getElementById("field_length_mm");
  if (auto){
    fr.value = Math.max(1, d.Routmm + mr).toFixed(0);
    fl.value = Math.max(1, d.Lmm + 2*mz).toFixed(0);
    fr.disabled = true;
    fl.disabled = true;
  }else{
    fr.disabled = false;
    fl.disabled = false;
  }

  setText("mode_badge", state.visMode === "points" ? "ç‚¹äº‘" : "ç£åœºçº¿");
}

/** ===================== å‡ ä½•æ„é€ ï¼šå¤šå±‚èºæ—‹ä¸­å¿ƒçº¿ ===================== */
function buildCoilCenterlines(p){
  const layers = [];
  const segMid = [];
  const segDl  = [];

  const phase0 = p.layer_phase_deg * Math.PI/180;
  const R_in_m = p.inner_radius_mm * 1e-3;
  const pitch_m = p.pitch_mm * 1e-3;
  const od_m = p.wire_od_mm * 1e-3;
  const gap_m = p.gap_radial_mm * 1e-3;

  const turns = p.turns_per_layer;
  const z0 = -0.5 * turns * pitch_m;
  const tMax = 2*Math.PI*turns;

  const nVis = turns * p.pts_per_turn_vis + 1;
  const nSeg = turns * p.seg_per_turn_field;
  const nF = nSeg + 1;

  for (let k=0; k<p.n_layers; k++){
    const Rk = R_in_m + (od_m/2) + k*(od_m + gap_m);
    const ph = phase0;

    const xmm = new Array(nVis);
    const ymm = new Array(nVis);
    const zmm = new Array(nVis);

    for (let i=0; i<nVis; i++){
      const t = tMax * (i/(nVis-1));
      const x = Rk*Math.cos(t+ph);
      const y = Rk*Math.sin(t+ph);
      const z = z0 + (pitch_m/(2*Math.PI))*t;
      xmm[i] = x*1e3;
      ymm[i] = y*1e3;
      zmm[i] = z*1e3;
    }
    layers.push({xmm, ymm, zmm});

    let px = 0, py = 0, pz = 0;
    for (let i=0; i<nF; i++){
      const t = tMax * (i/(nF-1));
      const x = Rk*Math.cos(t+ph);
      const y = Rk*Math.sin(t+ph);
      const z = z0 + (pitch_m/(2*Math.PI))*t;
      if (i>0){
        const dlx = x - px;
        const dly = y - py;
        const dlz = z - pz;
        const midx = 0.5*(x + px);
        const midy = 0.5*(y + py);
        const midz = 0.5*(z + pz);
        segDl.push(dlx, dly, dlz);
        segMid.push(midx, midy, midz);
      }
      px=x; py=y; pz=z;
    }
  }

  return {
    layers,
    segMid_m: new Float64Array(segMid),
    segDl_m: new Float64Array(segDl),
    meta: {
      coil_length_m: turns*pitch_m,
      turns_total: p.n_layers*turns,
      z0_m: -0.5*turns*pitch_m,
      z1_m:  0.5*turns*pitch_m,
    }
  };
}

/** ===================== Biotâ€“Savartï¼šç¦»æ•£çº¿æ®µå åŠ  ===================== */
function B_at_point_m(point_m, segMid_m, segDl_m, I, eps){
  const mu0_over_4pi = 1e-7;
  const sx = point_m[0], sy = point_m[1], sz = point_m[2];
  let bx=0, by=0, bz=0;
  const nSeg = segMid_m.length / 3;
  const eps2 = eps*eps;
  for (let i=0; i<nSeg; i++){
    const j = 3*i;
    const midx = segMid_m[j], midy = segMid_m[j+1], midz = segMid_m[j+2];
    const dlx  = segDl_m[j],  dly  = segDl_m[j+1],  dlz  = segDl_m[j+2];

    const rx = sx - midx;
    const ry = sy - midy;
    const rz = sz - midz;

    const r2 = rx*rx + ry*ry + rz*rz + eps2;
    const r = Math.sqrt(r2);
    const inv_r3 = 1.0 / (r2 * r);

    const cx = dly*rz - dlz*ry;
    const cy = dlz*rx - dlx*rz;
    const cz = dlx*ry - dly*rx;

    bx += cx * inv_r3;
    by += cy * inv_r3;
    bz += cz * inv_r3;
  }
  const scale = mu0_over_4pi * I;
  return [bx*scale, by*scale, bz*scale];
}

/** ===================== ç‚¹é‡‡æ ·ä¸ç£åœºè®¡ç®— ===================== */
function buildCylindricalSamples(radius_m, length_m, nz, nr, nt){
  const pts = [];
  const z0 = -0.5*length_m;
  const z1 =  0.5*length_m;
  for (let iz=0; iz<nz; iz++){
    const z = (nz===1) ? 0 : (z0 + (z1-z0)* (iz/(nz-1)));
    for (let ir=0; ir<nr; ir++){
      const r = (nr===1) ? 0 : (radius_m * (ir/(nr-1)));
      if (r === 0){
        pts.push({x:0, y:0, z});
      }else{
        for (let it=0; it<nt; it++){
          const th = 2*Math.PI * (it/nt);
          pts.push({x:r*Math.cos(th), y:r*Math.sin(th), z});
        }
      }
    }
  }
  return pts;
}

function computeFieldOnSamples(samples_m, segMid_m, segDl_m, I, eps){
  const n = samples_m.length;
  const xmm = new Array(n), ymm=new Array(n), zmm=new Array(n);
  const bx = new Array(n), by=new Array(n), bz=new Array(n);
  const bmag = new Array(n);

  for (let i=0; i<n; i++){
    const p = samples_m[i];
    const B = B_at_point_m([p.x,p.y,p.z], segMid_m, segDl_m, I, eps);
    bx[i]=B[0]; by[i]=B[1]; bz[i]=B[2];
    const bm = Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]);
    bmag[i]=bm;
    xmm[i]=p.x*1e3; ymm[i]=p.y*1e3; zmm[i]=p.z*1e3;
  }
  return {xmm, ymm, zmm, bx, by, bz, bmag_T: bmag};
}

function filterFieldByMinB(field, minB_T){
  const x=[],y=[],z=[], bx=[],by=[],bz=[], bmag=[];
  for (let i=0; i<field.bmag_T.length; i++){
    if (field.bmag_T[i] >= minB_T){
      x.push(field.xmm[i]); y.push(field.ymm[i]); z.push(field.zmm[i]);
      bx.push(field.bx[i]); by.push(field.by[i]); bz.push(field.bz[i]);
      bmag.push(field.bmag_T[i]);
    }
  }
  return {xmm:x, ymm:y, zmm:z, bx, by, bz, bmag_T:bmag};
}

/** ===================== ç®¡çŠ¶å¯¼ä½“ï¼ˆMesh3dï¼‰ ===================== */
function tubeMeshFromCenterline(center_xmm, center_ymm, center_zmm, tubeRadius_mm, sides){
  const n = center_xmm.length;
  if (n < 2) return null;
  const r = tubeRadius_mm;

  const vx = [];
  const vy = [];
  const vz = [];
  const ringIndex = new Array(n);

  function norm3(ax,ay,az){
    const s = Math.sqrt(ax*ax+ay*ay+az*az);
    if (s===0) return [0,0,0];
    return [ax/s, ay/s, az/s];
  }
  function cross(a,b){
    return [
      a[1]*b[2] - a[2]*b[1],
      a[2]*b[0] - a[0]*b[2],
      a[0]*b[1] - a[1]*b[0],
    ];
  }

  for (let idx=0; idx<n; idx++){
    ringIndex[idx] = vx.length;

    const cx = center_xmm[idx], cy=center_ymm[idx], cz=center_zmm[idx];
    let tx,ty,tz;
    if (idx === 0){
      tx = center_xmm[1]-center_xmm[0];
      ty = center_ymm[1]-center_ymm[0];
      tz = center_zmm[1]-center_zmm[0];
    }else if (idx === n-1){
      tx = center_xmm[n-1]-center_xmm[n-2];
      ty = center_ymm[n-1]-center_ymm[n-2];
      tz = center_zmm[n-1]-center_zmm[n-2];
    }else{
      tx = center_xmm[idx+1]-center_xmm[idx-1];
      ty = center_ymm[idx+1]-center_ymm[idx-1];
      tz = center_zmm[idx+1]-center_zmm[idx-1];
    }
    let T = norm3(tx,ty,tz);

    let V = [0,0,1];
    if (Math.abs(T[2]) > 0.95) V = [1,0,0];

    let N = cross(V, T);
    N = norm3(N[0],N[1],N[2]);
    let B = cross(T, N);
    B = norm3(B[0],B[1],B[2]);

    for (let s=0; s<sides; s++){
      const phi = 2*Math.PI*(s/sides);
      const c = Math.cos(phi), si = Math.sin(phi);
      const ox = r*(c*N[0] + si*B[0]);
      const oy = r*(c*N[1] + si*B[1]);
      const oz = r*(c*N[2] + si*B[2]);
      vx.push(cx+ox);
      vy.push(cy+oy);
      vz.push(cz+oz);
    }
  }

  const ti = [];
  const tj = [];
  const tk = [];
  for (let idx=0; idx<n-1; idx++){
    const a0 = ringIndex[idx];
    const b0 = ringIndex[idx+1];
    for (let s=0; s<sides; s++){
      const s1 = (s+1)%sides;
      const a = a0 + s;
      const a1= a0 + s1;
      const b = b0 + s;
      const b1= b0 + s1;
      ti.push(a);  tj.push(b);  tk.push(a1);
      ti.push(a1); tj.push(b);  tk.push(b1);
    }
  }
  return {x:vx, y:vy, z:vz, i:ti, j:tj, k:tk};
}

/** ===================== æ–¹å‘ç®­å¤´ï¼šçº¿æ®µ + åˆ†ç®±ç€è‰² ===================== */
function buildColoredArrowBins(fieldDirs, arrowLenMm, withHead, valueArr, cmin, cmax, nBins){
  const bins = [];
  for (let b=0; b<nBins; b++){
    const tMid = (nBins===1) ? 0.5 : (b/(nBins-1));
    bins.push({x:[],y:[],z:[], color: viridisRgba(tMid, 0.95)});
  }
  const headLen = arrowLenMm * 0.35;
  const headWid = arrowLenMm * 0.18;

  function norm3(ax,ay,az){
    const s = Math.sqrt(ax*ax+ay*ay+az*az);
    if (s===0) return [0,0,0];
    return [ax/s, ay/s, az/s];
  }
  function cross(ax,ay,az, bx,by,bz){
    return [ay*bz-az*by, az*bx-ax*bz, ax*by-ay*bx];
  }
  const denom = (cmax - cmin) + 1e-12;

  const n = fieldDirs.xmm.length;
  for (let i=0; i<n; i++){
    const bm = fieldDirs.bmag_T[i];
    if (!isFinite(bm) || bm <= 0) continue;

    const bx = fieldDirs.bx[i], by = fieldDirs.by[i], bz = fieldDirs.bz[i];
    const d = norm3(bx,by,bz);

    const v = valueArr[i];
    let t = (v - cmin) / denom;
    t = Math.max(0, Math.min(1, t));
    let bi = Math.floor(t * (nBins-1) + 1e-9);
    bi = Math.max(0, Math.min(nBins-1, bi));

    const sx = fieldDirs.xmm[i], sy = fieldDirs.ymm[i], sz = fieldDirs.zmm[i];
    const ex = sx + d[0]*arrowLenMm;
    const ey = sy + d[1]*arrowLenMm;
    const ez = sz + d[2]*arrowLenMm;

    bins[bi].x.push(sx, ex, null);
    bins[bi].y.push(sy, ey, null);
    bins[bi].z.push(sz, ez, null);

    if (withHead){
      let rx=0, ry=0, rz=1;
      if (Math.abs(d[2]) > 0.9){ rx=1; ry=0; rz=0; }
      let p = cross(d[0],d[1],d[2], rx,ry,rz);
      p = norm3(p[0],p[1],p[2]);

      const hx1 = ex - d[0]*headLen + p[0]*headWid;
      const hy1 = ey - d[1]*headLen + p[1]*headWid;
      const hz1 = ez - d[2]*headLen + p[2]*headWid;

      const hx2 = ex - d[0]*headLen - p[0]*headWid;
      const hy2 = ey - d[1]*headLen - p[1]*headWid;
      const hz2 = ez - d[2]*headLen - p[2]*headWid;

      bins[bi].x.push(ex, hx1, null, ex, hx2, null);
      bins[bi].y.push(ey, hy1, null, ey, hy2, null);
      bins[bi].z.push(ez, hz1, null, ez, hz2, null);
    }
  }
  return bins;
}

/** ===================== ç£åœºçº¿ï¼šç§¯åˆ† + åˆ†ç®±ç€è‰² ===================== */
function inDomain(p_m, radius_m, halfLen_m){
  const r = Math.sqrt(p_m[0]*p_m[0] + p_m[1]*p_m[1]);
  return (r <= radius_m) && (Math.abs(p_m[2]) <= halfLen_m);
}

function unitDirFromB(B){
  const bm = Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]);
  if (!isFinite(bm) || bm <= 0) return null;
  return [B[0]/bm, B[1]/bm, B[2]/bm, bm];
}

function stepRK2(p_m, h_m, sign, segMid_m, segDl_m, I, eps){
  // returns {p_next, bmag} using midpoint RK2 on direction field Â±B/|B|
  const B1 = B_at_point_m(p_m, segMid_m, segDl_m, I, eps);
  const u1 = unitDirFromB(B1);
  if (!u1) return null;
  const k1 = [sign*u1[0], sign*u1[1], sign*u1[2]];
  const mid = [p_m[0] + 0.5*h_m*k1[0], p_m[1] + 0.5*h_m*k1[1], p_m[2] + 0.5*h_m*k1[2]];
  const B2 = B_at_point_m(mid, segMid_m, segDl_m, I, eps);
  const u2 = unitDirFromB(B2);
  if (!u2) return null;
  const k2 = [sign*u2[0], sign*u2[1], sign*u2[2]];
  const next = [p_m[0] + h_m*k2[0], p_m[1] + h_m*k2[1], p_m[2] + h_m*k2[2]];
  return {p_next: next, bmag_T: u1[3]};
}

function integrateOneLine(seed_m, radius_m, halfLen_m, h_m, maxSteps, segMid_m, segDl_m, I, eps){
  // integrate both directions; return {xmm,ymm,zmm, bmag_T}
  function march(sign){
    const pts = [];
    const bms = [];
    let p = [seed_m[0], seed_m[1], seed_m[2]];
    for (let s=0; s<maxSteps; s++){
      if (!inDomain(p, radius_m, halfLen_m)) break;
      const B = B_at_point_m(p, segMid_m, segDl_m, I, eps);
      const u = unitDirFromB(B);
      if (!u) break;
      pts.push([p[0],p[1],p[2]]);
      bms.push(u[3]);
      const step = stepRK2(p, h_m, sign, segMid_m, segDl_m, I, eps);
      if (!step) break;
      p = step.p_next;
      if (!inDomain(p, radius_m, halfLen_m)) {
        // optionally include boundary point? skip
        break;
      }
    }
    return {pts, bms};
  }

  const back = march(-1);
  const fwd  = march(+1);

  // combine: reverse back, then fwd (skip duplicate seed)
  const ptsAll = [];
  const bAll = [];
  for (let i=back.pts.length-1; i>=0; i--){
    ptsAll.push(back.pts[i]);
    bAll.push(back.bms[i]);
  }
  if (fwd.pts.length > 0){
    for (let i=1; i<fwd.pts.length; i++){
      ptsAll.push(fwd.pts[i]);
      bAll.push(fwd.bms[i]);
    }
  }
  const xmm=[], ymm=[], zmm=[], bmag=[];
  for (let i=0; i<ptsAll.length; i++){
    const p = ptsAll[i];
    xmm.push(p[0]*1e3); ymm.push(p[1]*1e3); zmm.push(p[2]*1e3);
    bmag.push(bAll[i]);
  }
  return {xmm,ymm,zmm, bmag_T:bmag};
}

function buildStreamlines(p, radius_m, length_m, segMid_m, segDl_m, I, eps){
  const halfLen = 0.5*length_m;
  const zSeed_m = p.seed_z_mm * 1e-3;
  const rMax = radius_m * p.seed_r_max_frac;

  const nr = Math.max(1, p.seed_nr);
  const nt = Math.max(1, p.seed_nt);
  const seeds = [];

  for (let ir=0; ir<nr; ir++){
    const rr = (nr===1) ? rMax : (rMax * (ir/(nr-1)));
    if (rr === 0){
      seeds.push([0,0,zSeed_m]);
    }else{
      for (let it=0; it<nt; it++){
        const th = 2*Math.PI*(it/nt);
        seeds.push([rr*Math.cos(th), rr*Math.sin(th), zSeed_m]);
      }
    }
  }

  const h_m = p.line_step_mm * 1e-3;
  const maxSteps = p.line_max_steps;

  const lines = [];
  let Bmax = 0;
  for (const s of seeds){
    if (!inDomain(s, radius_m, halfLen)) continue;
    const line = integrateOneLine(s, radius_m, halfLen, h_m, maxSteps, segMid_m, segDl_m, I, eps);
    if (line.bmag_T.length >= 2){
      for (const b of line.bmag_T) Bmax = Math.max(Bmax, b);
      lines.push(line);
    }
  }
  return {lines, Bmax_T: Bmax};
}

function buildColoredLineBins(lines, valueLines, cmin, cmax, minVal, nBins){
  // lines: [{xmm,ymm,zmm}], valueLines: [{vals}] in display units (same length as points)
  const bins = [];
  for (let b=0; b<nBins; b++){
    const tMid = (nBins===1) ? 0.5 : (b/(nBins-1));
    bins.push({x:[],y:[],z:[], color: viridisRgba(tMid, 0.95)});
  }
  const denom = (cmax - cmin) + 1e-12;
  for (let li=0; li<lines.length; li++){
    const L = lines[li];
    const V = valueLines[li];
    const n = L.xmm.length;
    for (let i=0; i<n-1; i++){
      const vmid = 0.5*(V[i] + V[i+1]);
      if (vmid < minVal) continue;
      let t = (vmid - cmin)/denom;
      t = Math.max(0, Math.min(1, t));
      let bi = Math.floor(t*(nBins-1) + 1e-9);
      bi = Math.max(0, Math.min(nBins-1, bi));
      bins[bi].x.push(L.xmm[i], L.xmm[i+1], null);
      bins[bi].y.push(L.ymm[i], L.ymm[i+1], null);
      bins[bi].z.push(L.zmm[i], L.zmm[i+1], null);
    }
  }
  return bins;
}

/** ===================== è½´çº¿ä¸Šæœ€å¤§å€¼æ£€æŸ¥ ===================== */
function axisMaxCheck(segMid_m, segDl_m, I, eps, z0_m, z1_m, nSamples){
  let zBest = 0, bBest = -1;
  for (let i=0; i<nSamples; i++){
    const z = z0_m + (z1_m - z0_m) * (i/(nSamples-1));
    const B = B_at_point_m([0,0,z], segMid_m, segDl_m, I, eps);
    const bm = Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]);
    if (bm > bBest){
      bBest = bm;
      zBest = z;
    }
  }
  return {z_m:zBest, b_T:bBest};
}

/** ===================== Plotly ç»˜åˆ¶ ===================== */
function makeLayout(){
  return {
    margin:{l:0,r:0,t:0,b:0},
    scene:{
      xaxis:{title:"x (mm)", gridcolor:"rgba(255,255,255,.10)", zerolinecolor:"rgba(255,255,255,.15)"},
      yaxis:{title:"y (mm)", gridcolor:"rgba(255,255,255,.10)", zerolinecolor:"rgba(255,255,255,.15)"},
      zaxis:{title:"z (mm)", gridcolor:"rgba(255,255,255,.10)", zerolinecolor:"rgba(255,255,255,.15)"},
      aspectmode:"data",
      bgcolor:"rgba(0,0,0,0)",
      camera:{ eye:{x:1.6,y:1.4,z:0.9} }
    },
    showlegend:false,
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)",
  };
}

function setStatus(msg, kind){
  const el = document.getElementById("status");
  if (kind === "ok"){
    el.innerHTML = `çŠ¶æ€ï¼š<span class="ok">${msg}</span>`;
  }else if (kind === "bad"){
    el.innerHTML = `çŠ¶æ€ï¼š<span class="bad">${msg}</span>`;
  }else{
    el.textContent = "çŠ¶æ€ï¼š" + msg;
  }
}

function makeCoilTraces(p, coil){
  const traces = [];
  if (p.show_tube){
    for (let k=0; k<coil.layers.length; k++){
      const L = coil.layers[k];
      const outer = tubeMeshFromCenterline(L.xmm, L.ymm, L.zmm, p.wire_od_mm/2, p.tube_sides);
      if (outer){
        traces.push({
          type:"mesh3d",
          name:`å¯¼ä½“å¤–è¡¨é¢ L${k+1}`,
          x: outer.x, y: outer.y, z: outer.z,
          i: outer.i, j: outer.j, k: outer.k,
          opacity: p.show_hollow ? 0.55 : 0.95,
          showscale:false,
          hoverinfo:"skip",
        });
      }
      if (p.show_hollow && p.wire_id_mm > 0){
        const inner = tubeMeshFromCenterline(L.xmm, L.ymm, L.zmm, p.wire_id_mm/2, p.tube_sides);
        if (inner){
          traces.push({
            type:"mesh3d",
            name:`æ°´é“å†…å­” L${k+1}`,
            x: inner.x, y: inner.y, z: inner.z,
            i: inner.i, j: inner.j, k: inner.k,
            opacity: 0.20,
            showscale:false,
            hoverinfo:"skip",
          });
        }
      }
    }
  } else {
    for (let k=0; k<coil.layers.length; k++){
      const L = coil.layers[k];
      traces.push({
        type:"scatter3d",
        mode:"lines",
        name:`çº¿åœˆå±‚ ${k+1}`,
        x:L.xmm, y:L.ymm, z:L.zmm,
        line:{width:6},
        hoverinfo:"skip",
      });
    }
  }
  return traces;
}

/** ===================== ä¸»æµç¨‹ï¼šæ›´æ–°è®¡ç®—å¹¶ç»˜å›¾ ===================== */
async function updateAll(){
  const btn = document.getElementById("btn_update");
  btn.disabled = true;
  try{
    updateDerivedUI();
    const p = readParams();
    const errs = validateParams(p);
    if (errs.length){
      setStatus("å‚æ•°é”™è¯¯ï¼š " + errs.join("ï¼› "), "bad");
      btn.disabled = false;
      return;
    }

    setStatus("æ­£åœ¨ç”Ÿæˆçº¿åœˆå¹¶è®¡ç®—ç£åœºï¼ˆè¯·ç¨ç­‰ï¼‰â€¦");
    await new Promise(r => setTimeout(r, 20));

    const t0 = nowMs();
    const coil = buildCoilCenterlines(p);

    const radius_m = p.field_radius_mm * 1e-3;
    const length_m = p.field_length_mm * 1e-3;

    // Center field
    const B0 = B_at_point_m([0,0,0], coil.segMid_m, coil.segDl_m, p.current_A, p.epsilon_m);
    const B0mag = Math.sqrt(B0[0]*B0[0]+B0[1]*B0[1]+B0[2]*B0[2]);

    setText("bx0", fmtB(B0[0], p.field_unit));
    setText("by0", fmtB(B0[1], p.field_unit));
    setText("bz0", fmtB(B0[2], p.field_unit));
    setText("b0",  fmtB(B0mag, p.field_unit));

    // Axis max check on coil span
    const axis = axisMaxCheck(coil.segMid_m, coil.segDl_m, p.current_A, p.epsilon_m, coil.meta.z0_m, coil.meta.z1_m, 121);
    setText("axis_zmax", (axis.z_m*1e3).toFixed(2) + " mm");
    setText("axis_bmax", fmtB(axis.b_T, p.field_unit));

    // Sanity checks
    const mu0 = 4*Math.PI*1e-7;
    const Lc = coil.meta.coil_length_m;
    const N = coil.meta.turns_total;
    const n = N / Math.max(Lc, 1e-12);
    const B_long = mu0 * n * p.current_A;

    const d = derivedGeometry(p);
    const Rin = p.inner_radius_mm*1e-3;
    const Rout = d.Routmm*1e-3;
    const Rmean = 0.5*(Rin+Rout);
    const B_sheet = (mu0 * N * p.current_A) / (2 * Math.sqrt(Rmean*Rmean + (Lc/2)*(Lc/2)));

    setText("b_long", fmtB(B_long, p.field_unit));
    setText("b_sheet", fmtB(B_sheet, p.field_unit));

    // Build traces
    const traces = [];
    traces.push(...makeCoilTraces(p, coil));

    const unit = p.field_unit;

    if (state.visMode === "points"){
      // point cloud
      const samplesPts = buildCylindricalSamples(radius_m, length_m, p.pts_nz, p.pts_nr, p.pts_nt);
      const fieldPtsRaw = computeFieldOnSamples(samplesPts, coil.segMid_m, coil.segDl_m, p.current_A, p.epsilon_m);

      // threshold
      let BmaxPts = 0;
      for (const b of fieldPtsRaw.bmag_T) BmaxPts = Math.max(BmaxPts, b);
      const minB_T = p.display_min_frac * BmaxPts;
      const fieldPts = (minB_T>0) ? filterFieldByMinB(fieldPtsRaw, minB_T) : fieldPtsRaw;

      const pointVals = fieldPts.bmag_T.map(b => (unit==="G" ? b*1e4 : b));
      let cmin = Infinity, cmax = -Infinity;
      for (const v of pointVals){ cmin = Math.min(cmin, v); cmax = Math.max(cmax, v); }
      if (!isFinite(cmin) || !isFinite(cmax) || cmax<=cmin){ cmin = 0; cmax = 1; }

      const cTitle = unit==="G" ? "|B| (G)" : "|B| (T)";

      traces.push({
        type:"scatter3d",
        mode:"markers",
        name:"ç£åœºç‚¹äº‘ |B|",
        x: fieldPts.xmm, y: fieldPts.ymm, z: fieldPts.zmm,
        marker:{
          size: p.marker_size,
          color: pointVals,
          colorscale:"Viridis",
          opacity: 0.92,
          cmin, cmax,
          colorbar:{title:cTitle},
        },
        hovertemplate: `x=%{x:.1f}mm<br>y=%{y:.1f}mm<br>z=%{z:.1f}mm<br>|B|=%{marker.color:.3g} ${unit}<extra></extra>`
      });

      // direction arrows (optional)
      if (state.showDirs){
        const samplesDirs = buildCylindricalSamples(radius_m, length_m, p.dir_nz, p.dir_nr, p.dir_nt);
        const fieldDirsRaw = computeFieldOnSamples(samplesDirs, coil.segMid_m, coil.segDl_m, p.current_A, p.epsilon_m);
        const fieldDirs = (minB_T>0) ? filterFieldByMinB(fieldDirsRaw, minB_T) : fieldDirsRaw;
        const dirVals = fieldDirs.bmag_T.map(b => (unit==="G" ? b*1e4 : b));
        const bins = buildColoredArrowBins(fieldDirs, p.dir_len_mm, p.dir_head, dirVals, cmin, cmax, 18);
        for (const bin of bins){
          if (bin.x.length === 0) continue;
          traces.push({
            type:"scatter3d",
            mode:"lines",
            name:"æ–¹å‘ç®­å¤´",
            x: bin.x, y: bin.y, z: bin.z,
            line:{width:4, color:bin.color},
            hoverinfo:"skip",
          });
        }
      }

      const t1 = nowMs();
      const segCount = coil.segMid_m.length/3;
      setStatus(`å®Œæˆï¼ˆç‚¹äº‘æ¨¡å¼ï¼‰ã€‚çº¿æ®µæ•° ${segCount}ï¼›ç‚¹äº‘ ${fieldPts.bmag_T.length}ï¼›è€—æ—¶ ${(t1-t0).toFixed(0)} ms`, "ok");
    } else {
      // field lines mode
      const sl = buildStreamlines(p, radius_m, length_m, coil.segMid_m, coil.segDl_m, p.current_A, p.epsilon_m);

      // Convert b values to display units; determine scale
      const valueLines = [];
      let vmin = Infinity, vmax = -Infinity;
      for (const L of sl.lines){
        const vals = L.bmag_T.map(b => (unit==="G" ? b*1e4 : b));
        for (const v of vals){ vmin = Math.min(vmin, v); vmax = Math.max(vmax, v); }
        valueLines.push(vals);
      }
      if (!isFinite(vmin) || !isFinite(vmax) || vmax<=vmin){ vmin=0; vmax=1; }
      const cTitle = unit==="G" ? "|B| (G)" : "|B| (T)";

      // threshold based on vmax (display units)
      const minVal = p.display_min_frac * vmax;

      const bins = buildColoredLineBins(sl.lines, valueLines, vmin, vmax, minVal, 22);
      for (const bin of bins){
        if (bin.x.length === 0) continue;
        traces.push({
          type:"scatter3d",
          mode:"lines",
          name:"ç£åœºçº¿",
          x: bin.x, y: bin.y, z: bin.z,
          line:{width:4, color:bin.color},
          hoverinfo:"skip",
        });
      }

      // Colorbar anchor (invisible) so streamlines also show a colorbar
      traces.push({
        type:"scatter3d",
        mode:"markers",
        name:"colorbar",
        x:[0,0], y:[0,0], z:[0,0],
        marker:{
          size:0.1,
          opacity:0.0,
          color:[vmin, vmax],
          colorscale:"Viridis",
          cmin:vmin,
          cmax:vmax,
          colorbar:{title:cTitle},
        },
        hoverinfo:"skip",
        showlegend:false,
      });

      // optional direction arrows on top of lines
      if (state.showDirs){
        const samplesDirs = buildCylindricalSamples(radius_m, length_m, p.dir_nz, p.dir_nr, p.dir_nt);
        const fieldDirsRaw = computeFieldOnSamples(samplesDirs, coil.segMid_m, coil.segDl_m, p.current_A, p.epsilon_m);
        // filter arrows by threshold as well
        const fieldDirs = (minVal>0) ? (function(){
          const minB_T = (unit==="G") ? (minVal/1e4) : minVal;
          return filterFieldByMinB(fieldDirsRaw, minB_T);
        })() : fieldDirsRaw;
        const dirVals = fieldDirs.bmag_T.map(b => (unit==="G" ? b*1e4 : b));
        const binsA = buildColoredArrowBins(fieldDirs, p.dir_len_mm, p.dir_head, dirVals, vmin, vmax, 18);
        for (const bin of binsA){
          if (bin.x.length === 0) continue;
          traces.push({
            type:"scatter3d",
            mode:"lines",
            name:"æ–¹å‘ç®­å¤´",
            x: bin.x, y: bin.y, z: bin.z,
            line:{width:4, color:bin.color},
            hoverinfo:"skip",
          });
        }
      }

      const t1 = nowMs();
      const segCount = coil.segMid_m.length/3;
      setStatus(`å®Œæˆï¼ˆç£åœºçº¿æ¨¡å¼ï¼‰ã€‚çº¿æ®µæ•° ${segCount}ï¼›ç£åœºçº¿æ¡æ•° ${sl.lines.length}ï¼›è€—æ—¶ ${(t1-t0).toFixed(0)} ms`, "ok");
    }

    Plotly.react("plot", traces, makeLayout(), {responsive:true, displaylogo:false});
  }catch(err){
    console.error(err);
    setStatus("å‘ç”Ÿé”™è¯¯ï¼š" + (err?.message || String(err)), "bad");
  }finally{
    btn.disabled = false;
  }
}

/** ===================== UI äº¤äº’ ===================== */
function toggleMode(){
  state.visMode = (state.visMode === "points") ? "lines" : "points";
  // ç£åœºçº¿æ¨¡å¼é»˜è®¤æ›´æ¸…çˆ½ï¼šå…ˆæŠŠæ–¹å‘ç®­å¤´å…³æ‰ï¼ˆç”¨æˆ·å¯å†å¼€ï¼‰
  if (state.visMode === "lines") state.showDirs = false;
  updateDerivedUI();
  updateAll();
}
function toggleDirs(){
  state.showDirs = !state.showDirs;
  updateDerivedUI();
  updateAll();
}
function setStatusIdle(){
  setStatus("ç­‰å¾…è®¡ç®—â€¦");
}

function resetDefaults(){
  const defaults = {
    // geometry
    inner_radius_mm:15, n_layers:4, turns_per_layer:50, pitch_mm:6,
    wire_od_mm:6, wire_id_mm:4, gap_radial_mm:0.2, layer_phase_deg:0,
    // current/unit
    current_A:64, field_unit:"G",
    // domain
    auto_domain:true, domain_margin_r_mm:30, domain_margin_z_mm:30,
    field_radius_mm:60, field_length_mm:300,
    display_min_frac:0,
    // points/dirs
    marker_size:3, pts_nz:15, pts_nr:6, pts_nt:12,
    dir_nz:10, dir_nr:4, dir_nt:8, dir_len_mm:8, dir_head:true,
    // streamlines
    seed_z_mm:0, seed_r_max_frac:0.9, seed_nr:5, seed_nt:10,
    line_step_mm:6, line_max_steps:160,
    // perf
    pts_per_turn_vis:18, seg_per_turn_field:40, tube_sides:12, epsilon_m:"1e-6",
    // view
    show_tube:true, show_hollow:true,
  };
  for (const [k,v] of Object.entries(defaults)){
    const el = document.getElementById(k);
    if (!el) continue;
    if (el.type === "checkbox") el.checked = !!v;
    else el.value = v;
  }
  state.visMode = "points";
  state.showDirs = true;
  updateDerivedUI();
  updateAll();
}

document.getElementById("btn_update").addEventListener("click", updateAll);
document.getElementById("btn_reset").addEventListener("click", resetDefaults);
document.getElementById("btn_toggle_mode").addEventListener("click", toggleMode);
document.getElementById("btn_toggle_dir").addEventListener("click", toggleDirs);

for (const id of [
  "inner_radius_mm","n_layers","turns_per_layer","pitch_mm",
  "wire_od_mm","wire_id_mm","gap_radial_mm","current_A",
  "auto_domain","domain_margin_r_mm","domain_margin_z_mm","field_radius_mm","field_length_mm"
]){
  const el = document.getElementById(id);
  if (el){
    el.addEventListener("input", ()=>{updateDerivedUI(); setStatusIdle();});
    el.addEventListener("change", ()=>{updateDerivedUI(); setStatusIdle();});
  }
}

// initial
updateDerivedUI();
updateAll();
</script>
</body>
</html>
