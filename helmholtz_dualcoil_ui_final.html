<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Helicon åŒçº¿åœˆï¼ˆäº¥å§†éœå…¹ï¼‰è®¾è®¡å·¥å…·ï¼šç£åœº + ç”µé˜»/å‘çƒ­ + æ°´å†·ï¼ˆçº¯HTMLï¼‰</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    :root{
      --bg:#0b1020; --panel:#0f1733; --panel2:#0c132b;
      --text:#e8ecff; --muted:#b6c2ff; --border:rgba(255,255,255,.12);
      --danger:#ff6b6b; --ok:#2fe37a; --accent:#7aa2ff;
    }
    html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial;}
    body{background:var(--bg); color:var(--text);}
    .wrap{display:flex; height:100vh; overflow:hidden;}
    .left{
      width:470px; min-width:340px; max-width:760px;
      border-right:1px solid var(--border);
      background:linear-gradient(180deg, var(--panel), var(--panel2));
      padding:14px 14px 10px 14px;
      overflow:auto;
    }
    .right{flex:1; min-width:0; background:var(--bg); display:flex; flex-direction:column;}
    h1{font-size:16px; margin:0 0 10px 0; font-weight:950;}
    .hint{font-size:12px; color:var(--muted); line-height:1.55; margin-bottom:10px;}
    .toolbar{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 12px 0;}
    .btn{
      appearance:none; border:1px solid var(--border);
      background:rgba(122,162,255,.16); color:var(--text);
      padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:950;
      transition:transform .05s ease;
      user-select:none;
    }
    .btn:active{transform:translateY(1px);}
    .btn.primary{background:rgba(122,162,255,.28); border-color:rgba(122,162,255,.55);}
    .btn.ghost{background:rgba(255,255,255,.04);}
    .btn.danger{background:rgba(255,107,107,.18); border-color:rgba(255,107,107,.55);}
    .btn:disabled{opacity:.55; cursor:not-allowed;}
    .status{font-size:12px; line-height:1.45; margin-top:8px; color:var(--muted);}
    .status .ok{color:var(--ok); font-weight:950;}
    .status .bad{color:var(--danger); font-weight:950;}

    .grid{display:grid; grid-template-columns: 1fr 1fr; gap:10px 10px; align-items:end;}
    label{display:block; font-size:12px; color:var(--muted); margin:0 0 4px 2px;}
    input[type="number"], input[type="text"], select{
      width:100%; padding:8px 10px; border-radius:10px;
      border:1px solid var(--border); background:rgba(0,0,0,.20);
      color:var(--text); outline:none; box-sizing:border-box;
    }
    input[disabled]{opacity:.55; cursor:not-allowed;}
    input[type="number"]:focus, select:focus, input[type="text"]:focus{
      border-color:rgba(122,162,255,.7); box-shadow:0 0 0 3px rgba(122,162,255,.16);
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .chk{display:flex; gap:8px; align-items:center; font-size:12px; color:var(--muted); user-select:none; margin:6px 0;}
    .chk input{transform:translateY(1px);}
    .divider{height:1px; background:var(--border); margin:10px 0;}
    .small{font-size:12px; color:var(--muted); line-height:1.55;}

    .card{
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(255,255,255,.03);
      padding:12px;
      margin:10px 0;
    }
    .card h2{
      margin:0 0 10px 0;
      font-size:13px;
      font-weight:950;
    }
    .badge{
      display:inline-flex; padding:6px 10px; border-radius:10px;
      border:1px solid var(--border); background:rgba(255,255,255,.04);
      font-size:12px; color:var(--muted); gap:8px; align-items:center;
    }
    .badge b{color:var(--text); font-weight:950;}
    .kv{display:grid; grid-template-columns: 1fr 1fr; gap:8px 10px; font-size:12px; color:var(--muted);}
    .kv b{color:var(--text); font-weight:950;}
    .biggrid{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    .big{
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(0,0,0,.18);
      padding:10px;
    }
    .big .k{font-size:12px; color:var(--muted);}
    .big .v{font-size:16px; font-weight:950; margin-top:6px;}
    .big .s{font-size:12px; color:var(--muted); margin-top:4px;}

    details{
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(255,255,255,.03);
      padding:10px 12px;
      margin:10px 0;
    }
    details summary{
      cursor:pointer; color:var(--text); font-weight:950;
      font-size:13px;
      list-style:none;
      user-select:none;
    }
    details summary::-webkit-details-marker{display:none;}
    .sec{margin-top:10px;}

    /* Right: tabs */
    .tabs{
      display:flex;
      gap:8px;
      padding:10px;
      border-bottom:1px solid var(--border);
      background:rgba(255,255,255,.02);
      align-items:center;
      flex-wrap:wrap;
    }
    .tab{
      padding:8px 12px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      cursor:pointer;
      font-weight:950;
      font-size:12px;
      color:var(--muted);
      user-select:none;
    }
    .tab.active{
      color:var(--text);
      border-color:rgba(122,162,255,.55);
      background:rgba(122,162,255,.20);
    }
    .tabhint{margin-left:auto; color:var(--muted); font-size:12px;}

    .plots{flex:1; min-height:0; position:relative;}
    /* âš ï¸ æ³¨æ„ï¼šä¸è¦ç”¨ .plot ä½œä¸ºå®¹å™¨ç±»åï¼Œä¼šä¸ Plotly å†…éƒ¨çš„ .plot å†²çªå¯¼è‡´æ•°æ®å±‚è¢«éšè— */
    .pane{position:absolute; inset:0; width:100%; height:100%; display:none;}
    .pane.active{display:block;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <h1>Helicon åŒçº¿åœˆï¼ˆäº¥å§†éœå…¹ï¼‰è®¾è®¡å·¥å…·</h1>
    <div class="hint">
      é¡¶éƒ¨ä¼˜å…ˆå±•ç¤ºï¼š<b>ä¸­å¿ƒç£åœº</b> / <b>æ€»å‘çƒ­åŠŸç‡</b> / <b>æ°´å†·æ¨è</b>ã€‚<br>
      3D å¯çœ‹ç‚¹äº‘æˆ–ç£åœºçº¿ï¼›æˆªé¢/è½´çº¿ç”¨äºå¿«é€Ÿåˆ¤æ–­å‡åŒ€åŒºã€‚<br>
      è‹¥æ‹…å¿ƒâ€œé è¿‘å¯¼ä½“æå¤§å€¼â€å½±å“é…è‰²ï¼šæœ¬å·¥å…·å¯¹å¯¼ä½“é™„è¿‘åš<b>è½¯åŒ–</b>å¹¶é‡‡ç”¨<b>ç™¾åˆ†ä½é¢œè‰²èŒƒå›´</b>ï¼Œé¿å…ä¸€ç‰‡å‘é»‘ã€‚
    </div>

    <div class="toolbar">
      <button class="btn primary" id="btn_update">æ›´æ–°è®¡ç®—</button>
      <button class="btn ghost" id="btn_toggle_field_mode">ğŸ§² ç‚¹äº‘ / ç£åœºçº¿</button>
      <button class="btn ghost" id="btn_toggle_dirs">â†— æ–¹å‘</button>
      <button class="btn ghost" id="btn_cam_flat">ğŸ‘ å¹³æ”¾è§†è§’</button>
      <button class="btn ghost" id="btn_cam_std">ğŸ‘ æ ‡å‡†è§†è§’</button>
      <button class="btn danger" id="btn_reset">æ¢å¤é»˜è®¤</button>
      <span class="badge">æ˜¾ç¤ºï¼š<b id="badge_field_mode">ç‚¹äº‘</b></span>
    </div>

    <div class="card">
      <h2>å…³é”®ç»“æœï¼ˆä¼˜å…ˆå±•ç¤ºï¼‰</h2>
      <div class="biggrid">
        <div class="big">
          <div class="k">ä¸­å¿ƒç£åœº |B(0,0,0)|</div>
          <div class="v" id="out_B0">-</div>
          <div class="s">ä»¥åŠ Bz(0) = <span id="out_Bz0">-</span></div>
        </div>
        <div class="big">
          <div class="k">æ€»å‘çƒ­åŠŸç‡ P_total</div>
          <div class="v" id="out_Ptotal_big">-</div>
          <div class="s">å•çº¿åœˆç”µé˜» R_coil = <span id="out_Rcoil_big">-</span></div>
        </div>
        <div class="big">
          <div class="k">æ¨èæ°´å†·å¹¶è”è·¯æ•° n_recï¼ˆæ¯çº¿åœˆï¼‰</div>
          <div class="v" id="out_nrec_big">-</div>
          <div class="s">æ¨èæ—¶ï¼šÎ”P = <span id="out_dp_big">-</span>ï¼›v = <span id="out_v_big">-</span></div>
        </div>
        <div class="big">
          <div class="k">æ‰€éœ€æ€»æµé‡ Q_totalï¼ˆä¸¤çº¿åœˆï¼‰</div>
          <div class="v" id="out_Qtotal_big">-</div>
          <div class="s">å•çº¿åœˆ Q_coil = <span id="out_Qcoil_big">-</span>ï¼ˆæŒ‰ Î”Tï¼‰</div>
        </div>
      </div>

      <div class="divider"></div>
      <div class="kv">
        <div>è½´çº¿ä¸Šæœ€å¤§ |B|ï¼šz=<b id="axis_zmax">-</b></div>
        <div>è½´çº¿ä¸Šæœ€å¤§ |B|ï¼š<b id="axis_bmax">-</b></div>
      </div>

      <div class="status" id="status">çŠ¶æ€ï¼šç­‰å¾…è®¡ç®—â€¦</div>
    </div>

    


    <details open>
      <summary>å…³é”®å‚æ•°ï¼šåŒçº¿åœˆ + çº¿åœˆå‡ ä½•ï¼ˆå¸¸ç”¨ï¼‰</summary>
      <div class="sec">
        <div class="grid">
          <div>
            <label>ä¸¤çº¿åœˆä¸­å¿ƒé—´è· dï¼ˆmmï¼‰</label>
            <input type="number" id="coil_spacing_mm" value="300" step="1">
          </div>
          <div>
            <label>ç³»ç»Ÿä¸­å¿ƒ z_midï¼ˆmmï¼‰</label>
            <input type="number" id="coil_mid_z_mm" value="0" step="1">
          </div>

          <div>
            <label>æ¨¡å¼</label>
            <select id="coil_mode">
              <option value="helmholtz" selected>äº¥å§†éœå…¹ï¼ˆåŒå‘ç”µæµï¼‰</option>
              <option value="anti">åäº¥å§†éœå…¹ï¼ˆåå‘ç”µæµï¼‰</option>
              <option value="custom">è‡ªå®šä¹‰ï¼ˆI1ã€I2 ç‹¬ç«‹ï¼‰</option>
            </select>
          </div>
          <div>
            <label>çº¿åœˆ1 ç”µæµ I1ï¼ˆAï¼‰</label>
            <input type="number" id="current1_A" value="200" step="1">
          </div>

          <div>
            <label>çº¿åœˆ2 ç”µæµ I2ï¼ˆAï¼‰</label>
            <input type="number" id="current2_A" value="200" step="1">
          </div>
          <div>
            <label>å†…åŠå¾„ R_inï¼ˆmmï¼‰</label>
            <input type="number" id="inner_radius_mm" value="150" step="0.1" min="0">
          </div>

          <div>
            <label>å¾„å‘å±‚æ•°</label>
            <input type="number" id="n_layers" value="5" step="1" min="1" max="50">
          </div>
          <div>
            <label>æ¯å±‚åŒæ•°</label>
            <input type="number" id="turns_per_layer" value="10" step="1" min="1" max="50000">
          </div>

          <div>
            <label>é“œç®¡å¤–å¾„ OD_cuï¼ˆmmï¼‰</label>
            <input type="number" id="wire_od_mm" value="8" step="0.1" min="0.1">
          </div>
          <div>
            <label>æ°´é“å†…å¾„ IDï¼ˆmmï¼‰</label>
            <input type="number" id="wire_id_mm" value="6" step="0.1" min="0">
          </div>

          <div>
            <label>ç»ç¼˜åšåº¦ t_insï¼ˆmmï¼Œå•è¾¹ï¼‰</label>
            <input type="number" id="insulation_mm" value="0.2" step="0.05" min="0">
          </div>
          <div>
            <label>å±‚é—´é™„åŠ é—´éš™ gap_rï¼ˆmmï¼‰</label>
            <input type="number" id="gap_radial_mm" value="0.2" step="0.1">
          </div>

          <div>
            <label>è‡ªåŠ¨ pitchï¼ˆä¸­å¿ƒè· = OD_eff + gap_zï¼‰</label>
            <select id="auto_pitch">
              <option value="on" selected>å¼€å¯ï¼ˆæ¨èï¼‰</option>
              <option value="off">å…³é—­ï¼ˆæ‰‹åŠ¨ï¼‰</option>
            </select>
          </div>
          <div>
            <label>è½´å‘é™„åŠ é—´éš™ gap_zï¼ˆmmï¼‰</label>
            <input type="number" id="gap_axial_mm" value="0.0" step="0.1">
          </div>

          <div>
            <label>ä¸­å¿ƒè· pitchï¼ˆmmï¼‰</label>
            <input type="number" id="pitch_mm" value="8.4" step="0.001" min="0.001">
          </div>
          <div>
            <label>ï¼ˆå»ºè®®ï¼‰ç‚¹äº‘/æˆªé¢ ç²¾åº¦</label>
            <select id="quality_preset">
              <option value="fast">å¿«é€Ÿï¼ˆæ›´æµç•…ï¼‰</option>
              <option value="standard" selected>æ ‡å‡†ï¼ˆæ¨èï¼‰</option>
              <option value="fine">ç²¾ç»†ï¼ˆæ›´æ…¢ï¼‰</option>
              <option value="custom">è‡ªå®šä¹‰ï¼ˆé«˜çº§ï¼‰</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <span class="badge">OD_eff=<b id="d_od_eff">-</b></span>
          <span class="badge">å±‚é—´æ­¥è·=<b id="d_rad_step">-</b></span>
          <span class="badge">L_coil=<b id="d_Lcoil">-</b></span>
          <span class="badge">R_out=<b id="d_Rout">-</b></span>
          <span class="badge">R_mean=<b id="d_Rmean">-</b></span>
          <span class="badge">N=<b id="d_Ntotal">-</b></span>
        </div>
      </div>
    </details>

    <details open>
      <summary>å…³é”®å‚æ•°ï¼šæ°´å†·ç›®æ ‡ï¼ˆè‡ªåŠ¨æ¨èï¼‰</summary>
      <div class="sec">
        <div class="grid">
          <div>
            <label>å…è®¸æ°´æ¸©å‡ Î”Tï¼ˆÂ°Cï¼‰</label>
            <input type="number" id="water_dT_C" value="10" step="1" min="1">
          </div>
          <div>
            <label>æ³µå¯ç”¨å‹å·® Î”P_maxï¼ˆbarï¼‰</label>
            <input type="number" id="dp_max_bar" value="1.0" step="0.1" min="0.1">
          </div>

          <div>
            <label>æœ€å¤§æµé€Ÿ v_maxï¼ˆm/sï¼‰</label>
            <input type="number" id="v_max" value="2.5" step="0.1" min="0.2">
          </div>
          <div>
            <label>æ‰«æä¸Šé™ N_maxï¼ˆå¹¶è”è·¯æ•°ï¼‰</label>
            <input type="number" id="n_parallel_max" value="12" step="1" min="1" max="60">
          </div>
        </div>

        <div class="chk">
          <input type="checkbox" id="auto_parallel" checked>
          <label for="auto_parallel" style="margin:0;">è‡ªåŠ¨æ¨èå¹¶è”è·¯æ•°ï¼ˆn_recï¼‰</label>
        </div>

        <div class="small">
          å‹é™æŒ‰ Darcyâ€“Weisbach ä¼°ç®—ï¼ˆå«å±€éƒ¨æŸå¤± Kï¼‰ã€‚ç”¨äºå¿«é€Ÿé€‰å‹ï¼›å®é™…å·¥ç¨‹éœ€ç»“åˆè½¯ç®¡/æ¥å¤´/åˆ†é…å™¨ã€‚
        </div>
      </div>
    </details>

    <details open>
      <summary>æ˜¾ç¤ºä¸æˆªé¢</summary>
      <div class="sec">
        <div class="grid">
          <div>
            <label>é¢œè‰²å•ä½</label>
            <select id="field_unit">
              <option value="G" selected>Gauss (G)</option>
              <option value="T">Tesla (T)</option>
            </select>
          </div>
          <div>
            <label>æ˜¾ç¤ºé˜ˆå€¼ï¼ˆ0~1ï¼ŒæŒ‰æœ€å¤§å€¼æ¯”ä¾‹ï¼‰</label>
            <input type="number" id="display_min_frac" value="0" step="0.05" min="0" max="0.99">
          </div>

          <div>
            <label>è®¡ç®—åŸŸï¼šè‡ªåŠ¨ï¼Ÿ</label>
            <select id="auto_domain">
              <option value="on" selected>è‡ªåŠ¨ï¼ˆè·Ÿéšçº¿åœˆå¤–å½¢ï¼‰</option>
              <option value="off">æ‰‹åŠ¨ï¼ˆé«˜çº§ï¼‰</option>
            </select>
          </div>
          <div>
            <label>è½´å‘ margin_zï¼ˆmmï¼Œå¯ä¸ºè´Ÿï¼‰</label>
            <input type="number" id="domain_margin_z_mm" value="300" step="10">
          </div>

          <div>
            <label>å¾„å‘ margin_rï¼ˆmmï¼Œå¯ä¸ºè´Ÿï¼‰</label>
            <input type="number" id="domain_margin_r_mm" value="30" step="10">
          </div>
          <div>
            <label>æˆªé¢ä¸é€æ˜åº¦</label>
            <input type="number" id="slice_opacity" value="0.35" step="0.05" min="0" max="1">
          </div>
        </div>

        <div class="row" style="margin-top:8px; flex-wrap:wrap;">
          <span class="badge">R_domain=<b id="badge_Rdomain">-</b></span>
          <span class="badge">L_domain=<b id="badge_Ldomain">-</b></span>
        </div>
        <div class="small" style="margin-top:6px;">
          æç¤ºï¼šæ›´æ”¹ margin / åˆ‡æ¢è‡ªåŠ¨åŸŸåï¼Œä¼šè‡ªåŠ¨åˆ·æ–° 3D ç‚¹äº‘ä¸æˆªé¢ï¼ˆå¯èƒ½ç¨æ…¢ï¼‰ã€‚
        </div>

        <div class="chk">
          <input type="checkbox" id="show_slice_plane" checked>
          <label for="show_slice_plane" style="margin:0;">åœ¨ 3D é‡Œå åŠ æ˜¾ç¤ºæˆªé¢å¹³é¢</label>
        </div>

        <label style="margin-top:8px;">æˆªé¢æ—‹è½¬è§’ Ï†ï¼ˆ0~360Â°ï¼‰</label>
        <input type="range" id="slice_angle_deg" min="0" max="360" value="0" step="1" style="width:100%;">
        <div class="row" style="justify-content:space-between; margin-top:4px;">
          <span class="small">0</span>
          <span class="badge">Ï†=<b id="slice_angle_label">0</b>Â°</span>
          <span class="small">360</span>
        </div>

        <div class="small" style="margin-top:8px;">
          å³ä¾§ Tabï¼š<b>3D</b> / <b>æˆªé¢</b> / <b>è½´çº¿</b>ã€‚
        </div>
        <div class="divider"></div>

        <div class="chk">
          <input type="checkbox" id="slice_equal_aspect" checked>
          <label for="slice_equal_aspect" style="margin:0;">æˆªé¢åæ ‡ç­‰æ¯”ä¾‹æ˜¾ç¤ºï¼ˆ1 mm : 1 mmï¼‰</label>
        </div>

        <div class="chk">
          <input type="checkbox" id="show_chamber_lines" checked>
          <label for="show_chamber_lines" style="margin:0;">æˆªé¢å›¾æ˜¾ç¤ºâ€œå°è…”å®¤â€è¾¹ç•Œï¼ˆä¸¤æ¡ç«–ç›´è™šçº¿ï¼Œå¯æ‹–æ‹½ï¼‰</label>
        </div>

        <div class="grid">
          <div>
            <label>å°è…”å®¤åŠå¾„ r_chamberï¼ˆmmï¼‰</label>
            <input type="number" id="chamber_radius_mm" value="60" step="1" min="0">
          </div>
        </div>

        <div class="small" style="margin-top:8px;">
          æç¤ºï¼šå³ä¾§ã€Œæˆªé¢ã€Tab ä¸­å¯ç›´æ¥æ‹–åŠ¨è™šçº¿æ”¹å˜ r_chamberï¼ˆæ‹–åŠ¨ä»»æ„ä¸€æ¡ï¼Œå¦ä¸€æ¡è‡ªåŠ¨é•œåƒï¼‰ã€‚
        </div>

      </div>
    </details>

    <details>
      <summary>é«˜çº§è®¾ç½®ï¼ˆä¸€èˆ¬ä¸æ”¹ï¼‰</summary>
      <div class="sec">
        <div class="grid">
          <div>
            <label>ç”µè¿æ¥ï¼ˆåªå½±å“åŠŸç‡æ±‡æ€»æ˜¾ç¤ºï¼‰</label>
            <select id="elec_wiring">
              <option value="separate" selected>ä¸¤çº¿åœˆåˆ†åˆ«ä¾›ç”µ</option>
              <option value="series">ä¸¤çº¿åœˆä¸²è”</option>
              <option value="parallel">ä¸¤çº¿åœˆå¹¶è”</option>
            </select>
          </div>
          <div>
            <label>å±€éƒ¨æŸå¤±ç³»æ•° Kï¼ˆå¼¯å¤´/æ¥å¤´ï¼‰</label>
            <input type="number" id="minor_K" value="3" step="0.5" min="0">
          </div>

          <div>
            <label>é“œæ¸©åº¦ T_cuï¼ˆÂ°Cï¼‰</label>
            <input type="number" id="temp_cu_C" value="40" step="1">
          </div>
          <div>
            <label>é¢å¤–å¼•çº¿é•¿åº¦ï¼ˆæ¯çº¿åœˆï¼Œmï¼‰</label>
            <input type="number" id="extra_lead_m" value="0.5" step="0.1" min="0">
          </div>

          <div>
            <label>é“œç”µé˜»ç‡ Ï(20Â°C)ï¼ˆÎ©Â·mï¼‰</label>
            <input type="text" id="rho20" value="1.68e-8">
          </div>
          <div>
            <label>æ¸©åº¦ç³»æ•° Î±ï¼ˆ1/Â°Cï¼‰</label>
            <input type="number" id="alpha_cu" value="0.00393" step="0.0001">
          </div>

          <div>
            <label>æ˜¾ç¤ºï¼šç®¡çŠ¶å¯¼ä½“</label>
            <select id="show_tube_sel">
              <option value="on" selected>æ˜¾ç¤º</option>
              <option value="off">ä¸æ˜¾ç¤º</option>
            </select>
          </div>
          <div>
            <label>æ˜¾ç¤ºï¼šæ°´é“å†…å­”</label>
            <select id="show_hollow_sel">
              <option value="on" selected>æ˜¾ç¤º</option>
              <option value="off">ä¸æ˜¾ç¤º</option>
            </select>
          </div>

          <div>
            <label>æ˜¾ç¤ºï¼šç»ç¼˜å¤–å¾„ï¼ˆåŠé€æ˜ï¼‰</label>
            <select id="show_insulation_shell">
              <option value="on" selected>æ˜¾ç¤º</option>
              <option value="off">ä¸æ˜¾ç¤º</option>
            </select>
          </div>
          <div>
            <label>æ¯å±‚èµ·å§‹è§’åº¦åç§»ï¼ˆdegï¼‰</label>
            <input type="number" id="layer_phase_deg" value="0" step="1">
          </div>

          <div>
            <label>ç‚¹å¤§å°</label>
            <input type="number" id="marker_size" value="3" step="1" min="1" max="12">
          </div>
          <div>
            <label>æ–¹å‘ç®­å¤´é•¿åº¦ï¼ˆmmï¼‰</label>
            <input type="number" id="dir_len_mm" value="10" step="1" min="1">
          </div>

          <div>
            <label>R_domainï¼ˆmmï¼Œæ‰‹åŠ¨æ—¶ï¼‰</label>
            <input type="number" id="field_radius_mm" value="260" step="1" min="1">
          </div>
          <div>
            <label>L_domainï¼ˆmmï¼Œæ‰‹åŠ¨æ—¶ï¼‰</label>
            <input type="number" id="field_length_mm" value="1600" step="1" min="1">
          </div>

          <div>
            <label>æˆªé¢ç½‘æ ¼ nu Ã— nz</label>
            <div class="row">
              <input type="number" id="slice_nu" value="81" step="10" min="21" max="401" style="width:110px">
              <input type="number" id="slice_nz" value="121" step="10" min="31" max="501" style="width:110px">
            </div>
          </div>
          <div>
            <label>æˆªé¢åŠå¾„ u_maxï¼ˆmmï¼Œ0=R_domainï¼‰</label>
            <input type="number" id="slice_umax_mm" value="0" step="10" min="0">
          </div>

          <div>
            <label>ç‚¹äº‘å¯†åº¦ï¼ˆz Ã— r Ã— Î¸ï¼‰</label>
            <div class="row">
              <input type="number" id="pts_nz" value="23" step="1" min="2" style="width:90px">
              <input type="number" id="pts_nr" value="7" step="1" min="2" style="width:90px">
              <input type="number" id="pts_nt" value="14" step="1" min="1" style="width:90px">
            </div>
          </div>
          <div>
            <label>æ–¹å‘å¯†åº¦ï¼ˆz Ã— r Ã— Î¸ï¼‰</label>
            <div class="row">
              <input type="number" id="dir_nz" value="12" step="1" min="2" style="width:90px">
              <input type="number" id="dir_nr" value="4" step="1" min="2" style="width:90px">
              <input type="number" id="dir_nt" value="10" step="1" min="1" style="width:90px">
            </div>
          </div>

          <div class="chk" style="margin:0;">
            <input type="checkbox" id="dir_head" checked>
            <label for="dir_head" style="margin:0;">ç®­å¤´å¸¦å¤´éƒ¨</label>
          </div>
          <div class="small">
            é¢œè‰²èŒƒå›´é‡‡ç”¨ç™¾åˆ†ä½ï¼ˆ2%~98%ï¼‰é¿å…â€œæç«¯ç‚¹å…¨é»‘â€ã€‚
          </div>

          <div>
            <label>å¯è§†åŒ–ï¼šæ¯åŒç‚¹æ•°</label>
            <input type="number" id="pts_per_turn_vis" value="16" step="1" min="6" max="100">
          </div>
          <div>
            <label>ç£åœºç§¯åˆ†ï¼šæ¯åŒåˆ†æ®µæ•°</label>
            <input type="number" id="seg_per_turn_field" value="35" step="5" min="10" max="400">
          </div>

          <div>
            <label>ç®¡çŠ¶å¯¼ä½“ï¼šåœ†å‘¨åˆ†æ®µ</label>
            <input type="number" id="tube_sides" value="12" step="1" min="6" max="48">
          </div>
          <div>
            <label>æ•°å€¼ç¨³å®š epsilonï¼ˆmï¼‰</label>
            <input type="text" id="epsilon_m" value="1e-6">
          </div>

          <div>
            <label>ç£åœºçº¿ï¼šæ’­ç§ z_seedï¼ˆmmï¼‰</label>
            <input type="number" id="seed_z_mm" value="0" step="10">
          </div>
          <div>
            <label>ç£åœºçº¿ï¼šç§å­åŠå¾„æ¯”ä¾‹ï¼ˆ0~1ï¼‰</label>
            <input type="number" id="seed_r_max_frac" value="0.6" step="0.05" min="0.05" max="1">
          </div>

          <div>
            <label>ç£åœºçº¿ï¼šç§å­æ•° N_r Ã— N_Î¸</label>
            <div class="row">
              <input type="number" id="seed_nr" value="6" step="1" min="1" max="60" style="width:110px">
              <input type="number" id="seed_nt" value="12" step="1" min="1" max="120" style="width:110px">
            </div>
          </div>
          <div>
            <label>ç£åœºçº¿ï¼šæ­¥é•¿ dsï¼ˆmmï¼‰ / æœ€å¤§æ­¥æ•°</label>
            <div class="row">
              <input type="number" id="line_step_mm" value="10" step="1" min="1" style="width:110px">
              <input type="number" id="line_max_steps" value="200" step="10" min="20" max="2000" style="width:110px">
            </div>
          </div>
        </div>
      </div>
    </details>

    <!-- Hidden legacy switches -->
    <input type="hidden" id="water_temp_C" value="20">
    <input type="hidden" id="n_parallel" value="1">
  </div>

  <div class="right">
    <div class="tabs">
      <div class="tab active" data-tab="3d">3D</div>
      <div class="tab" data-tab="slice">æˆªé¢</div>
      <div class="tab" data-tab="axis">è½´çº¿</div>
      <div class="tabhint">æç¤ºï¼šæ‹–æ‹½æ—‹è½¬ï¼›æ»šè½®ç¼©æ”¾</div>
    </div>
    <div class="plots">
      <div id="plot3d" class="pane active"></div>
      <div id="plotSlice" class="pane"></div>
      <div id="plotAxis" class="pane"></div>
    </div>
  </div>
</div>

<script>
/** ===================== DOM helpers ===================== */
function el(id){ return document.getElementById(id); }
function toNumber(id){ return Number(el(id).value); }
function toFloatText(id){ return Number(String(el(id).value).trim()); }
function setText(id, txt){ el(id).textContent = txt; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/** ===================== Formatting ===================== */
function fmt(val, unit="", digits=3){
  if (!isFinite(val)) return "NaN";
  return val.toFixed(digits) + (unit?(" "+unit):"");
}
function fmtB(valTesla, unitSel){
  if (!isFinite(valTesla)) return "NaN";
  if (unitSel === "G") return (valTesla*1e4).toFixed(3) + " G";
  return valTesla.toFixed(6) + " T";
}
function setStatus(msg, kind){
  const s = el("status");
  if (kind === "ok") s.innerHTML = `çŠ¶æ€ï¼š<span class="ok">${msg}</span>`;
  else if (kind === "bad") s.innerHTML = `çŠ¶æ€ï¼š<span class="bad">${msg}</span>`;
  else s.textContent = "çŠ¶æ€ï¼š" + msg;
}

/** ===================== Viridis utilities ===================== */
const VIRIDIS = [
  [0.0,   "#440154"], [0.111, "#482878"], [0.222, "#3e4989"], [0.333, "#31688e"],
  [0.444, "#26828e"], [0.555, "#1f9e89"], [0.666, "#35b779"], [0.777, "#6ece58"],
  [0.888, "#b5de2b"], [1.0,   "#fde725"],
];
function hexToRgb(hex){
  const h = hex.replace("#","");
  const v = parseInt(h,16);
  return [(v>>16)&255, (v>>8)&255, v&255];
}
function lerp(a,b,t){ return a + (b-a)*t; }
function viridisRgb(t){
  t = clamp(t, 0, 1);
  for (let i=0; i<VIRIDIS.length-1; i++){
    const a = VIRIDIS[i], b = VIRIDIS[i+1];
    if (t >= a[0] && t <= b[0]){
      const tt = (t - a[0]) / (b[0]-a[0] + 1e-12);
      const ra = hexToRgb(a[1]), rb = hexToRgb(b[1]);
      return [Math.round(lerp(ra[0],rb[0],tt)), Math.round(lerp(ra[1],rb[1],tt)), Math.round(lerp(ra[2],rb[2],tt))];
    }
  }
  return hexToRgb(VIRIDIS[VIRIDIS.length-1][1]);
}
function viridisRgba(t, alpha){
  const rgb = viridisRgb(t);
  return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${alpha})`;
}

/** ===================== Robust color range (percentiles) ===================== */
function quantileSorted(sorted, q){
  const n = sorted.length;
  if (n === 0) return NaN;
  const pos = (n-1)*q;
  const base = Math.floor(pos);
  const rest = pos - base;
  if (base+1 < n) return sorted[base] + rest*(sorted[base+1]-sorted[base]);
  return sorted[base];
}
function robustRange(values, qLow=0.02, qHigh=0.98){
  const arr = [];
  for (const v of values){ if (isFinite(v)) arr.push(v); }
  arr.sort((a,b)=>a-b);
  if (arr.length < 2) return {cmin:0, cmax:1};
  let cmin = quantileSorted(arr, qLow);
  let cmax = quantileSorted(arr, qHigh);
  if (!isFinite(cmin) || !isFinite(cmax) || cmax<=cmin){
    cmin = arr[0];
    cmax = arr[arr.length-1];
  }
  if (cmax<=cmin) cmax = cmin + 1e-12;
  return {cmin, cmax};
}

/** ===================== State & cache ===================== */
let state = { fieldMode:"points", showDirs:true, activeTab:"3d" };
let updateInProgress = false;
let updatePending = false;

let autoUpdateTimer = null;
function scheduleUpdate(delayMs=260, forceRebuild=false){
  if (autoUpdateTimer) clearTimeout(autoUpdateTimer);
  autoUpdateTimer = setTimeout(()=>updateAll(forceRebuild), delayMs);
}

const CAM_STD = {eye:{x:1.6,y:1.4,z:0.9}, up:{x:0,y:0,z:1}, center:{x:0,y:0,z:0}};
const CAM_FLAT = {eye:{x:1.8,y:1.2,z:0.05}, up:{x:0,y:1,z:0}, center:{x:0,y:0,z:0}};
let cameraState = {...CAM_STD};

let cache = {
  lastParamsKey:null,
  coil1:null, coil2:null,
  segMid_m:null, segDlI_m:null,
  slice:null,
  sliceTraceIndex3d:null,
};

let sliceEventsBound = false;
let sliceShapeSyncLock = false;

/** ===================== Camera persistence ===================== */
function bindCameraPersistence(){
  const gd = el("plot3d");
  gd.on('plotly_relayout', (ev)=>{
    if (ev && ev["scene.camera"]){
      cameraState = ev["scene.camera"];
    }
  });
}
function setCameraPreset(preset){
  cameraState = JSON.parse(JSON.stringify(preset));
  try{
    Plotly.relayout("plot3d", {"scene.camera": cameraState});
  }catch(e){}
}

/** ===================== Geometry derivations ===================== */
function derivedGeometry(p){
  const od_eff = p.wire_od_mm + 2*p.insulation_mm;
  const rad_step = od_eff + p.gap_radial_mm;
  const L_coil = p.turns_per_layer * p.pitch_mm;
  const Rout = p.inner_radius_mm + od_eff + (p.n_layers-1)*rad_step;

  let sumR = 0;
  for (let k=0; k<p.n_layers; k++){
    sumR += (p.inner_radius_mm + od_eff/2 + k*rad_step);
  }
  const Rmean = sumR / p.n_layers;
  const Ntotal = p.n_layers * p.turns_per_layer;

  // helix length per coil
  const pitch_m = p.pitch_mm * 1e-3;
  let Lwire = 0;
  for (let k=0; k<p.n_layers; k++){
    const Rk_m = (p.inner_radius_mm + od_eff/2 + k*rad_step) * 1e-3;
    const lenPerTurn = Math.sqrt((2*Math.PI*Rk_m)**2 + pitch_m**2);
    Lwire += p.turns_per_layer * lenPerTurn;
  }
  Lwire += p.extra_lead_m;
  return {od_eff, rad_step, L_coil, Rout, Rmean, Ntotal, Lwire_m:Lwire};
}

/** ===================== Read params ===================== */
function readParams(){
  const mode = el("coil_mode").value;

  let I1 = toNumber("current1_A");
  let I2 = toNumber("current2_A");
  if (mode === "helmholtz"){ I2 = I1; }
  if (mode === "anti"){ I2 = -I1; }

  const autoPitch = el("auto_pitch").value === "on";
  const od = toNumber("wire_od_mm");
  const ins = toNumber("insulation_mm");
  const gapZ = toNumber("gap_axial_mm");
  const od_eff = od + 2*ins;

  let pitch = toNumber("pitch_mm");
  if (autoPitch){
    pitch = Math.max(0.001, od_eff + gapZ);
  }

  const p = {
    coil_spacing_mm: toNumber("coil_spacing_mm"),
    coil_mid_z_mm: toNumber("coil_mid_z_mm"),
    coil_mode: mode,
    elec_wiring: el("elec_wiring").value,
    current1_A: I1,
    current2_A: I2,

    inner_radius_mm: toNumber("inner_radius_mm"),
    n_layers: Math.round(toNumber("n_layers")),
    turns_per_layer: Math.round(toNumber("turns_per_layer")),
    pitch_mm: pitch,
    wire_od_mm: od,
    wire_id_mm: toNumber("wire_id_mm"),
    insulation_mm: ins,
    gap_radial_mm: toNumber("gap_radial_mm"),
    gap_axial_mm: gapZ,
    auto_pitch: autoPitch,

    layer_phase_deg: toNumber("layer_phase_deg"),
    show_insulation_shell: el("show_insulation_shell").value === "on",
    show_tube: el("show_tube_sel").value === "on",
    show_hollow: el("show_hollow_sel").value === "on",

    field_unit: el("field_unit").value,
    display_min_frac: clamp(toNumber("display_min_frac"), 0, 0.99),

    auto_domain: el("auto_domain").value === "on",
    domain_margin_r_mm: toNumber("domain_margin_r_mm"),
    domain_margin_z_mm: toNumber("domain_margin_z_mm"),
    field_radius_mm: toNumber("field_radius_mm"),
    field_length_mm: toNumber("field_length_mm"),

    marker_size: Math.round(toNumber("marker_size")),
    pts_nz: Math.round(toNumber("pts_nz")),
    pts_nr: Math.round(toNumber("pts_nr")),
    pts_nt: Math.round(toNumber("pts_nt")),

    dir_nz: Math.round(toNumber("dir_nz")),
    dir_nr: Math.round(toNumber("dir_nr")),
    dir_nt: Math.round(toNumber("dir_nt")),
    dir_len_mm: toNumber("dir_len_mm"),
    dir_head: el("dir_head").checked,

    show_slice_plane: el("show_slice_plane").checked,
    slice_opacity: clamp(toNumber("slice_opacity"), 0, 1),
    slice_angle_deg: Number(el("slice_angle_deg").value),
    slice_nu: Math.round(toNumber("slice_nu")),
    slice_nz: Math.round(toNumber("slice_nz")),
    slice_umax_mm: toNumber("slice_umax_mm"),

    seed_z_mm: toNumber("seed_z_mm"),
    seed_r_max_frac: clamp(toNumber("seed_r_max_frac"), 0.05, 1.0),
    seed_nr: Math.round(toNumber("seed_nr")),
    seed_nt: Math.round(toNumber("seed_nt")),
    line_step_mm: toNumber("line_step_mm"),
    line_max_steps: Math.round(toNumber("line_max_steps")),

    pts_per_turn_vis: Math.round(toNumber("pts_per_turn_vis")),
    seg_per_turn_field: Math.round(toNumber("seg_per_turn_field")),
    tube_sides: Math.round(toNumber("tube_sides")),
    epsilon_m: toFloatText("epsilon_m"),

    rho20: Number(String(el("rho20").value).trim()),
    alpha_cu: toNumber("alpha_cu"),
    temp_cu_C: toNumber("temp_cu_C"),
    extra_lead_m: toNumber("extra_lead_m"),

    water_dT_C: toNumber("water_dT_C"),
    dp_max_bar: toNumber("dp_max_bar"),
    v_max: toNumber("v_max"),
    n_parallel_max: Math.round(toNumber("n_parallel_max")),
    auto_parallel: el("auto_parallel").checked,
    minor_K: toNumber("minor_K"),

    // Slice view helpers
    slice_equal_aspect: el("slice_equal_aspect") ? el("slice_equal_aspect").checked : true,
    show_chamber_lines: el("show_chamber_lines") ? el("show_chamber_lines").checked : true,
    chamber_radius_mm: toNumber("chamber_radius_mm"),
  };

  const d = derivedGeometry(p);
  if (p.auto_domain){
    p.field_radius_mm = Math.max(1, d.Rout + p.domain_margin_r_mm);
    const Lpair = d.L_coil + p.coil_spacing_mm;
    p.field_length_mm = Math.max(1, Lpair + 2*p.domain_margin_z_mm);
  }
  return {p, d};
}

function validateParams(p){
  const errs = [];
  if (!(p.n_layers >= 1)) errs.push("å±‚æ•°å¿…é¡» â‰¥ 1");
  if (!(p.turns_per_layer >= 1)) errs.push("æ¯å±‚åŒæ•°å¿…é¡» â‰¥ 1");
  if (!(p.pitch_mm > 0)) errs.push("pitch å¿…é¡» > 0");
  if (!(p.wire_od_mm > 0)) errs.push("OD å¿…é¡» > 0");
  if (!(p.wire_id_mm >= 0)) errs.push("ID å¿…é¡» â‰¥ 0");
  if (p.wire_id_mm >= p.wire_od_mm) errs.push("ID å¿…é¡» < OD");
  if (!(p.insulation_mm >= 0)) errs.push("ç»ç¼˜åšåº¦å¿…é¡» â‰¥ 0");
  if (!(p.seg_per_turn_field >= 10)) errs.push("æ¯åŒåˆ†æ®µæ•°å¤ªå°ï¼ˆå»ºè®®â‰¥10ï¼‰");
  if (!(p.pts_per_turn_vis >= 6)) errs.push("æ¯åŒå¯è§†åŒ–ç‚¹æ•°å¤ªå°ï¼ˆå»ºè®®â‰¥6ï¼‰");
  if (!(p.field_radius_mm > 0 && p.field_length_mm > 0)) errs.push("è®¡ç®—åŸŸå¿…é¡» > 0");
  if (!(p.epsilon_m > 0)) errs.push("epsilon å¿…é¡» > 0");
  if (!(p.dir_len_mm > 0)) errs.push("æ–¹å‘ç®­å¤´é•¿åº¦å¿…é¡» > 0");
  if (!(p.marker_size >= 1)) errs.push("ç‚¹å¤§å°å¿…é¡» â‰¥ 1");
  if (!(p.line_step_mm > 0)) errs.push("ç£åœºçº¿æ­¥é•¿å¿…é¡» > 0");
  if (!(p.line_max_steps >= 20)) errs.push("ç£åœºçº¿æœ€å¤§æ­¥æ•°å¤ªå°");
  if (!(p.slice_nu >= 21 && p.slice_nz >= 31)) errs.push("æˆªé¢ç½‘æ ¼å¤ªå°");
  if (!(p.rho20 > 0)) errs.push("Ï(20Â°C) å¿…é¡» > 0");
  if (!(p.alpha_cu >= 0)) errs.push("Î± å¿…é¡» â‰¥ 0");
  if (!(p.water_dT_C > 0)) errs.push("Î”T å¿…é¡» > 0");
  if (!(p.dp_max_bar > 0)) errs.push("Î”P_max å¿…é¡» > 0");
  if (!(p.v_max > 0)) errs.push("v_max å¿…é¡» > 0");
  if (!(p.n_parallel_max >= 1)) errs.push("N_max å¿…é¡» â‰¥ 1");
  if (!(p.chamber_radius_mm >= 0)) errs.push("r_chamber å¿…é¡» â‰¥ 0");
  return errs;
}

/** ===================== Derived UI updates ===================== */
function updateDerivedUI(){
  const mode = el("coil_mode").value;
  const i2 = el("current2_A");
  if (mode === "custom"){
    i2.disabled = false;
  }else{
    i2.disabled = true;
    const i1 = toNumber("current1_A");
    i2.value = (mode === "helmholtz") ? i1 : (-i1);
  }

  const autoPitch = el("auto_pitch").value === "on";
  el("pitch_mm").disabled = autoPitch;
  if (autoPitch){
    const od = toNumber("wire_od_mm");
    const ins = toNumber("insulation_mm");
    const gapZ = toNumber("gap_axial_mm");
    const pitch = Math.max(0.001, od + 2*ins + gapZ);
    el("pitch_mm").value = pitch.toFixed(3);
  }

  const preset = el("quality_preset").value;
  if (preset !== "custom"){
    if (preset === "fast"){
      el("seg_per_turn_field").value = "22";
      el("pts_per_turn_vis").value = "10";
      el("pts_nz").value = "17";
      el("pts_nr").value = "6";
      el("pts_nt").value = "12";
      el("dir_nz").value = "9";
      el("dir_nr").value = "3";
      el("dir_nt").value = "8";
      el("slice_nu").value = "61";
      el("slice_nz").value = "91";
      el("tube_sides").value = "10";
      el("seed_nr").value = "5";
      el("seed_nt").value = "10";
      el("line_max_steps").value = "160";
    }else if (preset === "standard"){
      el("seg_per_turn_field").value = "35";
      el("pts_per_turn_vis").value = "16";
      el("pts_nz").value = "23";
      el("pts_nr").value = "7";
      el("pts_nt").value = "14";
      el("dir_nz").value = "12";
      el("dir_nr").value = "4";
      el("dir_nt").value = "10";
      el("slice_nu").value = "81";
      el("slice_nz").value = "121";
      el("tube_sides").value = "12";
      el("seed_nr").value = "6";
      el("seed_nt").value = "12";
      el("line_max_steps").value = "200";
    }else if (preset === "fine"){
      el("seg_per_turn_field").value = "65";
      el("pts_per_turn_vis").value = "24";
      el("pts_nz").value = "31";
      el("pts_nr").value = "9";
      el("pts_nt").value = "18";
      el("dir_nz").value = "16";
      el("dir_nr").value = "5";
      el("dir_nt").value = "14";
      el("slice_nu").value = "121";
      el("slice_nz").value = "181";
      el("tube_sides").value = "16";
      el("seed_nr").value = "8";
      el("seed_nt").value = "18";
      el("line_max_steps").value = "320";
    }
  }

  const {p, d} = readParams();
  if (p.auto_domain){
    el("field_radius_mm").value = p.field_radius_mm.toFixed(0);
    el("field_length_mm").value = p.field_length_mm.toFixed(0);
    el("field_radius_mm").disabled = true;
    el("field_length_mm").disabled = true;
  }else{
    el("field_radius_mm").disabled = false;
    el("field_length_mm").disabled = false;
  }

  if (el("badge_Rdomain")) setText("badge_Rdomain", fmt(p.field_radius_mm, "mm", 0));
  if (el("badge_Ldomain")) setText("badge_Ldomain", fmt(p.field_length_mm, "mm", 0));

  setText("d_od_eff", fmt(d.od_eff, "mm", 3));
  setText("d_rad_step", fmt(d.rad_step, "mm", 3));
  setText("d_Lcoil", fmt(d.L_coil, "mm", 1));
  setText("d_Rout", fmt(d.Rout, "mm", 1));
  setText("d_Rmean", fmt(d.Rmean, "mm", 1));
  setText("d_Ntotal", String(d.Ntotal));

  setText("slice_angle_label", String(Math.round(Number(el("slice_angle_deg").value))));
  setText("badge_field_mode", state.fieldMode === "points" ? "ç‚¹äº‘" : "ç£åœºçº¿");
}

/** ===================== Coil build ===================== */
function buildSingleCoil(p, z_center_m){
  const layers = [];
  const segMid = [];
  const segDl  = [];

  const phase0 = p.layer_phase_deg * Math.PI/180;
  const od_eff_m = (p.wire_od_mm + 2*p.insulation_mm) * 1e-3;
  const gap_r_m = p.gap_radial_mm * 1e-3;
  const rad_step_m = od_eff_m + gap_r_m;

  const R_in_m = p.inner_radius_mm * 1e-3;
  const pitch_m = p.pitch_mm * 1e-3;

  const turns = p.turns_per_layer;
  const z0_rel = -0.5 * turns * pitch_m;
  const tMax = 2*Math.PI*turns;

  const nVis = turns * p.pts_per_turn_vis + 1;
  const nSeg = turns * p.seg_per_turn_field;
  const nF = nSeg + 1;

  for (let k=0; k<p.n_layers; k++){
    const Rk = R_in_m + od_eff_m/2 + k*rad_step_m;
    const ph = phase0;

    const xmm = new Array(nVis);
    const ymm = new Array(nVis);
    const zmm = new Array(nVis);

    for (let i=0; i<nVis; i++){
      const t = tMax * (i/(nVis-1));
      const x = Rk*Math.cos(t+ph);
      const y = Rk*Math.sin(t+ph);
      const z = z_center_m + z0_rel + (pitch_m/(2*Math.PI))*t;
      xmm[i] = x*1e3;
      ymm[i] = y*1e3;
      zmm[i] = z*1e3;
    }
    layers.push({xmm, ymm, zmm, Rk_m:Rk});

    let px=0,py=0,pz=0;
    for (let i=0; i<nF; i++){
      const t = tMax * (i/(nF-1));
      const x = Rk*Math.cos(t+ph);
      const y = Rk*Math.sin(t+ph);
      const z = z_center_m + z0_rel + (pitch_m/(2*Math.PI))*t;
      if (i>0){
        segDl.push(x-px, y-py, z-pz);
        segMid.push(0.5*(x+px), 0.5*(y+py), 0.5*(z+pz));
      }
      px=x;py=y;pz=z;
    }
  }

  return {
    layers,
    segMid_m: new Float64Array(segMid),
    segDl_m: new Float64Array(segDl),
  };
}

function combineSegments(coil1, I1, coil2, I2){
  const n1 = coil1.segMid_m.length;
  const n2 = coil2.segMid_m.length;
  const segMid = new Float64Array(n1 + n2);
  const segDlI = new Float64Array(n1 + n2);

  segMid.set(coil1.segMid_m, 0);
  segMid.set(coil2.segMid_m, n1);

  for (let i=0;i<n1;i++) segDlI[i] = coil1.segDl_m[i] * I1;
  for (let i=0;i<n2;i++) segDlI[n1+i] = coil2.segDl_m[i] * I2;
  return {segMid_m: segMid, segDlI_m: segDlI};
}

/** ===================== Biotâ€“Savart ===================== */
function B_at_point_scaled(point_m, segMid_m, segDlI_m, eps_m, rmin_m){
  const mu0_over_4pi = 1e-7;
  const sx=point_m[0], sy=point_m[1], sz=point_m[2];
  let bx=0,by=0,bz=0;
  const nSeg = segMid_m.length/3;
  const eps2 = eps_m*eps_m;
  const rmin2 = rmin_m*rmin_m;

  for (let i=0; i<nSeg; i++){
    const j = 3*i;
    const midx = segMid_m[j], midy = segMid_m[j+1], midz = segMid_m[j+2];
    const dlxI = segDlI_m[j], dlyI = segDlI_m[j+1], dlzI = segDlI_m[j+2];

    const rx = sx - midx;
    const ry = sy - midy;
    const rz = sz - midz;

    let r2 = rx*rx + ry*ry + rz*rz;
    if (r2 < rmin2) r2 = rmin2;
    r2 += eps2;

    const r = Math.sqrt(r2);
    const inv_r3 = 1.0 / (r2 * r);

    const cx = dlyI*rz - dlzI*ry;
    const cy = dlzI*rx - dlxI*rz;
    const cz = dlxI*ry - dlyI*rx;

    bx += cx * inv_r3;
    by += cy * inv_r3;
    bz += cz * inv_r3;
  }
  return [bx*mu0_over_4pi, by*mu0_over_4pi, bz*mu0_over_4pi];
}

/** ===================== Sampling & field compute ===================== */
function buildCylindricalSamples(radius_m, length_m, nz, nr, nt){
  const pts=[];
  const z0=-0.5*length_m, z1=0.5*length_m;
  for (let iz=0; iz<nz; iz++){
    const z = (nz===1)?0:(z0+(z1-z0)*(iz/(nz-1)));
    for (let ir=0; ir<nr; ir++){
      const r = (nr===1)?0:(radius_m*(ir/(nr-1)));
      if (r===0){
        pts.push([0,0,z]);
      }else{
        for (let it=0; it<nt; it++){
          const th=2*Math.PI*(it/nt);
          pts.push([r*Math.cos(th), r*Math.sin(th), z]);
        }
      }
    }
  }
  return pts;
}

function computeFieldOnPoints(points_m, Bfunc){
  const n = points_m.length;
  const xmm=new Array(n), ymm=new Array(n), zmm=new Array(n);
  const bx=new Array(n), by=new Array(n), bz=new Array(n), bmag=new Array(n);
  for (let i=0;i<n;i++){
    const p = points_m[i];
    const B = Bfunc(p);
    bx[i]=B[0]; by[i]=B[1]; bz[i]=B[2];
    const bm = Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]);
    bmag[i]=bm;
    xmm[i]=p[0]*1e3; ymm[i]=p[1]*1e3; zmm[i]=p[2]*1e3;
  }
  return {xmm,ymm,zmm,bx,by,bz,bmag_T:bmag};
}
function filterByMinB(field, minB_T){
  const x=[],y=[],z=[], bx=[],by=[],bz=[], bmag=[];
  for (let i=0;i<field.bmag_T.length;i++){
    if (field.bmag_T[i] >= minB_T){
      x.push(field.xmm[i]); y.push(field.ymm[i]); z.push(field.zmm[i]);
      bx.push(field.bx[i]); by.push(field.by[i]); bz.push(field.bz[i]);
      bmag.push(field.bmag_T[i]);
    }
  }
  return {xmm:x, ymm:y, zmm:z, bx,by,bz, bmag_T:bmag};
}

/** ===================== Tube mesh ===================== */
function tubeMeshFromCenterline(center_xmm, center_ymm, center_zmm, tubeRadius_mm, sides){
  const n=center_xmm.length;
  if (n<2) return null;
  const r=tubeRadius_mm;
  const vx=[],vy=[],vz=[];
  const ringIndex=new Array(n);

  function norm3(ax,ay,az){
    const s=Math.sqrt(ax*ax+ay*ay+az*az);
    if (s===0) return [0,0,0];
    return [ax/s,ay/s,az/s];
  }
  function cross(a,b){
    return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
  }

  for (let idx=0; idx<n; idx++){
    ringIndex[idx]=vx.length;
    const cx=center_xmm[idx], cy=center_ymm[idx], cz=center_zmm[idx];
    let tx,ty,tz;
    if (idx===0){
      tx=center_xmm[1]-center_xmm[0]; ty=center_ymm[1]-center_ymm[0]; tz=center_zmm[1]-center_zmm[0];
    }else if (idx===n-1){
      tx=center_xmm[n-1]-center_xmm[n-2]; ty=center_ymm[n-1]-center_ymm[n-2]; tz=center_zmm[n-1]-center_zmm[n-2];
    }else{
      tx=center_xmm[idx+1]-center_xmm[idx-1]; ty=center_ymm[idx+1]-center_ymm[idx-1]; tz=center_zmm[idx+1]-center_zmm[idx-1];
    }
    let T=norm3(tx,ty,tz);
    let V=[0,0,1];
    if (Math.abs(T[2])>0.95) V=[1,0,0];
    let N=cross(V,T); N=norm3(N[0],N[1],N[2]);
    let B=cross(T,N); B=norm3(B[0],B[1],B[2]);

    for (let s=0;s<sides;s++){
      const phi=2*Math.PI*(s/sides);
      const c=Math.cos(phi), si=Math.sin(phi);
      const ox=r*(c*N[0]+si*B[0]);
      const oy=r*(c*N[1]+si*B[1]);
      const oz=r*(c*N[2]+si*B[2]);
      vx.push(cx+ox); vy.push(cy+oy); vz.push(cz+oz);
    }
  }

  const ti=[],tj=[],tk=[];
  for (let idx=0; idx<n-1; idx++){
    const a0=ringIndex[idx], b0=ringIndex[idx+1];
    for (let s=0;s<sides;s++){
      const s1=(s+1)%sides;
      const a=a0+s, a1=a0+s1, b=b0+s, b1=b0+s1;
      ti.push(a); tj.push(b); tk.push(a1);
      ti.push(a1); tj.push(b); tk.push(b1);
    }
  }
  return {x:vx,y:vy,z:vz,i:ti,j:tj,k:tk};
}

/** ===================== Traces for coils ===================== */
function makeCoilTraces(p, coil, namePrefix){
  const traces=[];
  for (let k=0;k<coil.layers.length;k++){
    const L=coil.layers[k];
    if (p.show_tube){
      const outerCu = tubeMeshFromCenterline(L.xmm,L.ymm,L.zmm,p.wire_od_mm/2,p.tube_sides);
      if (outerCu){
        traces.push({type:"mesh3d", name:`${namePrefix} é“œç®¡`,
          x:outerCu.x,y:outerCu.y,z:outerCu.z,i:outerCu.i,j:outerCu.j,k:outerCu.k,
          opacity:0.85, showscale:false, hoverinfo:"skip"});
      }
      if (p.show_insulation_shell && p.insulation_mm>0){
        const shell = tubeMeshFromCenterline(L.xmm,L.ymm,L.zmm,(p.wire_od_mm/2 + p.insulation_mm),p.tube_sides);
        if (shell){
          traces.push({type:"mesh3d", name:`${namePrefix} ç»ç¼˜`,
            x:shell.x,y:shell.y,z:shell.z,i:shell.i,j:shell.j,k:shell.k,
            opacity:0.18, showscale:false, hoverinfo:"skip"});
        }
      }
      if (p.show_hollow && p.wire_id_mm>0){
        const inner = tubeMeshFromCenterline(L.xmm,L.ymm,L.zmm,p.wire_id_mm/2,p.tube_sides);
        if (inner){
          traces.push({type:"mesh3d", name:`${namePrefix} æ°´é“`,
            x:inner.x,y:inner.y,z:inner.z,i:inner.i,j:inner.j,k:inner.k,
            opacity:0.22, showscale:false, hoverinfo:"skip"});
        }
      }
    }else{
      traces.push({type:"scatter3d", mode:"lines", name:`${namePrefix} å±‚${k+1}`,
        x:L.xmm,y:L.ymm,z:L.zmm, line:{width:5}, hoverinfo:"skip"});
    }
  }
  return traces;
}

/** ===================== Direction arrows (colored by |B| bins) ===================== */
function buildColoredArrowBins(fieldDirs, arrowLenMm, withHead, valueArr, cmin, cmax, nBins){
  const bins=[];
  for (let b=0;b<nBins;b++){
    const tMid=(nBins===1)?0.5:(b/(nBins-1));
    bins.push({x:[],y:[],z:[], color:viridisRgba(tMid,0.95)});
  }
  const headLen=arrowLenMm*0.35;
  const headWid=arrowLenMm*0.18;

  function norm3(ax,ay,az){
    const s=Math.sqrt(ax*ax+ay*ay+az*az);
    if (s===0) return [0,0,0];
    return [ax/s,ay/s,az/s];
  }
  function cross(ax,ay,az,bx,by,bz){ return [ay*bz-az*by, az*bx-ax*bz, ax*by-ay*bx]; }

  const denom=(cmax-cmin)+1e-12;
  const n=fieldDirs.xmm.length;

  for (let i=0;i<n;i++){
    const bm=fieldDirs.bmag_T[i];
    if (!isFinite(bm) || bm<=0) continue;

    const d=norm3(fieldDirs.bx[i], fieldDirs.by[i], fieldDirs.bz[i]);

    let t=(valueArr[i]-cmin)/denom; t=clamp(t,0,1);
    let bi=Math.floor(t*(nBins-1)+1e-9); bi=clamp(bi,0,nBins-1);

    const sx=fieldDirs.xmm[i], sy=fieldDirs.ymm[i], sz=fieldDirs.zmm[i];
    const ex=sx+d[0]*arrowLenMm, ey=sy+d[1]*arrowLenMm, ez=sz+d[2]*arrowLenMm;

    bins[bi].x.push(sx,ex,null);
    bins[bi].y.push(sy,ey,null);
    bins[bi].z.push(sz,ez,null);

    if (withHead){
      let rx=0,ry=0,rz=1;
      if (Math.abs(d[2])>0.9){ rx=1;ry=0;rz=0; }
      let p=cross(d[0],d[1],d[2], rx,ry,rz);
      p=norm3(p[0],p[1],p[2]);

      const hx1=ex-d[0]*headLen+p[0]*headWid;
      const hy1=ey-d[1]*headLen+p[1]*headWid;
      const hz1=ez-d[2]*headLen+p[2]*headWid;

      const hx2=ex-d[0]*headLen-p[0]*headWid;
      const hy2=ey-d[1]*headLen-p[1]*headWid;
      const hz2=ez-d[2]*headLen-p[2]*headWid;

      bins[bi].x.push(ex,hx1,null, ex,hx2,null);
      bins[bi].y.push(ey,hy1,null, ey,hy2,null);
      bins[bi].z.push(ez,hz1,null, ez,hz2,null);
    }
  }
  return bins;
}

/** ===================== Streamlines ===================== */
function inDomain(p_m, radius_m, halfLen_m){
  const r=Math.sqrt(p_m[0]*p_m[0]+p_m[1]*p_m[1]);
  return (r<=radius_m) && (Math.abs(p_m[2])<=halfLen_m);
}
function unitDirFromB(B){
  const bm=Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]);
  if (!isFinite(bm) || bm<=0) return null;
  return [B[0]/bm, B[1]/bm, B[2]/bm, bm];
}
function stepRK2(p_m, h_m, sign, Bfunc){
  const u1=unitDirFromB(Bfunc(p_m)); if (!u1) return null;
  const k1=[sign*u1[0],sign*u1[1],sign*u1[2]];
  const mid=[p_m[0]+0.5*h_m*k1[0], p_m[1]+0.5*h_m*k1[1], p_m[2]+0.5*h_m*k1[2]];
  const u2=unitDirFromB(Bfunc(mid)); if (!u2) return null;
  const k2=[sign*u2[0],sign*u2[1],sign*u2[2]];
  const nxt=[p_m[0]+h_m*k2[0], p_m[1]+h_m*k2[1], p_m[2]+h_m*k2[2]];
  return {p_next:nxt, bmag_T:u1[3]};
}
function integrateOneLine(seed_m, radius_m, halfLen_m, h_m, maxSteps, Bfunc){
  function march(sign){
    const pts=[], bms=[];
    let p=[seed_m[0],seed_m[1],seed_m[2]];
    for (let s=0;s<maxSteps;s++){
      if (!inDomain(p,radius_m,halfLen_m)) break;
      const u=unitDirFromB(Bfunc(p)); if (!u) break;
      pts.push([p[0],p[1],p[2]]); bms.push(u[3]);
      const st=stepRK2(p,h_m,sign,Bfunc); if (!st) break;
      p=st.p_next;
    }
    return {pts,bms};
  }
  const back=march(-1), fwd=march(+1);
  const ptsAll=[], bAll=[];
  for (let i=back.pts.length-1;i>=0;i--){ ptsAll.push(back.pts[i]); bAll.push(back.bms[i]); }
  for (let i=1;i<fwd.pts.length;i++){ ptsAll.push(fwd.pts[i]); bAll.push(fwd.bms[i]); }
  const xmm=[],ymm=[],zmm=[],bmag=[];
  for (let i=0;i<ptsAll.length;i++){
    const p=ptsAll[i];
    xmm.push(p[0]*1e3); ymm.push(p[1]*1e3); zmm.push(p[2]*1e3); bmag.push(bAll[i]);
  }
  return {xmm,ymm,zmm,bmag_T:bmag};
}
function buildStreamlines(p, radius_m, length_m, Bfunc){
  const halfLen=0.5*length_m;
  const zSeed=p.seed_z_mm*1e-3;
  const rMax=radius_m*p.seed_r_max_frac;
  const nr=Math.max(1,p.seed_nr), nt=Math.max(1,p.seed_nt);
  const seeds=[];
  for (let ir=0;ir<nr;ir++){
    const rr=(nr===1)?rMax:(rMax*(ir/(nr-1)));
    if (rr===0){ seeds.push([0,0,zSeed]); }
    else{
      for (let it=0;it<nt;it++){
        const th=2*Math.PI*(it/nt);
        seeds.push([rr*Math.cos(th), rr*Math.sin(th), zSeed]);
      }
    }
  }
  const h=p.line_step_mm*1e-3, maxSteps=p.line_max_steps;
  const lines=[];
  for (const s of seeds){
    if (!inDomain(s,radius_m,halfLen)) continue;
    const L=integrateOneLine(s,radius_m,halfLen,h,maxSteps,Bfunc);
    if (L.bmag_T.length>=2) lines.push(L);
  }
  return {lines};
}
function buildColoredLineBins(lines, valueLines, cmin, cmax, minVal, nBins){
  const bins=[];
  for (let b=0;b<nBins;b++){
    const tMid=(nBins===1)?0.5:(b/(nBins-1));
    bins.push({x:[],y:[],z:[], color:viridisRgba(tMid,0.95)});
  }
  const denom=(cmax-cmin)+1e-12;
  for (let li=0;li<lines.length;li++){
    const L=lines[li], V=valueLines[li];
    for (let i=0;i<L.xmm.length-1;i++){
      const vmid=0.5*(V[i]+V[i+1]);
      if (vmid<minVal) continue;
      let t=(vmid-cmin)/denom; t=clamp(t,0,1);
      let bi=Math.floor(t*(nBins-1)+1e-9); bi=clamp(bi,0,nBins-1);
      bins[bi].x.push(L.xmm[i],L.xmm[i+1],null);
      bins[bi].y.push(L.ymm[i],L.ymm[i+1],null);
      bins[bi].z.push(L.zmm[i],L.zmm[i+1],null);
    }
  }
  return bins;
}

/** ===================== Slice (base plane y=0, rotate around z) ===================== */
function computeSliceBase(uMax_mm, length_mm, nu, nz, Bfunc){
  const uMax = uMax_mm * 1e-3;
  const halfL = 0.5 * length_mm * 1e-3;

  const uAxis = [];
  const zAxis = [];
  for (let iu=0; iu<nu; iu++){
    const u = (-uMax) + (2*uMax) * (iu/(nu-1));
    uAxis.push(u);
  }
  for (let iz=0; iz<nz; iz++){
    const z = (-halfL) + (2*halfL) * (iz/(nz-1));
    zAxis.push(z);
  }

  // |B| & Bz on the slice plane (y=0 before rotation)
  const bmag2d = new Array(nz);
  const bz2d   = new Array(nz);
  const flatMag = [];
  const flatBz  = [];

  for (let iz=0; iz<nz; iz++){
    const rowMag = new Array(nu);
    const rowBz  = new Array(nu);
    const z = zAxis[iz];
    for (let iu=0; iu<nu; iu++){
      const x = uAxis[iu];
      const B = Bfunc([x, 0, z]);
      const bz = B[2];
      const bm = Math.sqrt(B[0]*B[0] + B[1]*B[1] + B[2]*B[2]);
      rowMag[iu] = bm;
      rowBz[iu]  = bz;
      flatMag.push(bm);
      flatBz.push(bz);
    }
    bmag2d[iz] = rowMag;
    bz2d[iz]   = rowBz;
  }
  return {
    uAxis_m:uAxis,
    zAxis_m:zAxis,
    bmag_T_2d:bmag2d,
    bz_T_2d:bz2d,
    flat_T:flatMag,
    flatBz_T:flatBz,
    uMax_mm
  };
}
function buildSliceSurfaceXYZ(uAxis_m, zAxis_m, angleDeg){
  const phi = angleDeg * Math.PI/180;
  const c = Math.cos(phi), s = Math.sin(phi);
  const nu = uAxis_m.length;
  const nz = zAxis_m.length;

  const X = new Array(nz);
  const Y = new Array(nz);
  const Z = new Array(nz);

  for (let iz=0; iz<nz; iz++){
    const xr = new Array(nu);
    const yr = new Array(nu);
    const zr = new Array(nu);
    const z = zAxis_m[iz]*1e3;
    for (let iu=0; iu<nu; iu++){
      const u_mm = uAxis_m[iu]*1e3;
      xr[iu] = u_mm * c;
      yr[iu] = u_mm * s;
      zr[iu] = z;
    }
    X[iz]=xr; Y[iz]=yr; Z[iz]=zr;
  }
  return {X,Y,Z};
}



/** ===================== Slice helpers: chamber lines ===================== */
function buildChamberShapes(p){
  if (!p.show_chamber_lines) return [];
  const r = Math.max(0, p.chamber_radius_mm);
  if (!(r > 0)) return [];
  const line = {color:"rgba(232,236,255,0.75)", width:2, dash:"dash"};
  return [
    {type:"line", xref:"x", yref:"paper", x0:-r, x1:-r, y0:0, y1:1, line, editable:true},
    {type:"line", xref:"x", yref:"paper", x0:+r, x1:+r, y0:0, y1:1, line, editable:true},
  ];
}

function bindSliceEvents(){
  if (sliceEventsBound) return;
  const gd = el("plotSlice");
  if (!gd || !gd.on) return;

  gd.on('plotly_relayout', (ev)=>{
    if (!ev) return;

    // Sync dashed chamber lines & numeric input when user drags either line.
    if (sliceShapeSyncLock) return;

    let x = null;
    if (ev["shapes[0].x0"] !== undefined) x = ev["shapes[0].x0"];
    else if (ev["shapes[1].x0"] !== undefined) x = ev["shapes[1].x0"];
    else if (ev["shapes[0].x1"] !== undefined) x = ev["shapes[0].x1"];
    else if (ev["shapes[1].x1"] !== undefined) x = ev["shapes[1].x1"];

    if (x !== null && isFinite(x)){
      const r = Math.abs(x);

      if (el("chamber_radius_mm")){
        el("chamber_radius_mm").value = r.toFixed(1).replace(/\.0$/,"");
      }

      sliceShapeSyncLock = true;
      Plotly.relayout("plotSlice", {
        "shapes[0].x0": -r, "shapes[0].x1": -r,
        "shapes[1].x0":  r, "shapes[1].x1":  r,
      }).then(()=>{
        sliceShapeSyncLock = false;
      }).catch(()=>{
        sliceShapeSyncLock = false;
      });
    }
  });

  sliceEventsBound = true;
}


/** ===================== Axis curve ===================== */
function computeAxisCurve(zSpan_mm, n, Bfunc){
  const z0 = -0.5*zSpan_mm*1e-3;
  const z1 =  0.5*zSpan_mm*1e-3;
  const zmm = [];
  const bz = [];
  const bmag = [];
  for (let i=0; i<n; i++){
    const z = z0 + (z1-z0)*(i/(n-1));
    const B = Bfunc([0,0,z]);
    const bm = Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]);
    zmm.push(z*1e3);
    bz.push(B[2]);
    bmag.push(bm);
  }
  return {zmm, bz_T:bz, bmag_T:bmag};
}

/** ===================== Electrical & cooling ===================== */
function computeResistanceAndPower(p, d){
  const OD_m = p.wire_od_mm*1e-3;
  const ID_m = p.wire_id_mm*1e-3;
  const Acu = Math.PI/4 * (OD_m*OD_m - ID_m*ID_m);

  const rho = p.rho20 * (1 + p.alpha_cu*(p.temp_cu_C - 20.0));
  const Rcoil = rho * d.Lwire_m / (Acu + 1e-30);

  const P1 = p.current1_A*p.current1_A*Rcoil;
  const P2 = p.current2_A*p.current2_A*Rcoil;
  const Ptotal = P1 + P2;

  return {Acu_m2:Acu, rho, Rcoil_ohm:Rcoil, P1_W:P1, P2_W:P2, Ptotal_W:Ptotal};
}
function frictionFactor(Re){
  if (!isFinite(Re) || Re <= 0) return NaN;
  if (Re < 2300) return 64/Re;
  if (Re > 4000) return 0.3164/Math.pow(Re, 0.25);
  const f_lam = 64/2300;
  const f_tur = 0.3164/Math.pow(4000,0.25);
  const t = (Re-2300)/(4000-2300);
  return f_lam*(1-t) + f_tur*t;
}
function coolingForOneCoil(p, d, Pcoil_W, nParallel){
  const rho = 997;
  const mu  = 1.002e-3;
  const cp  = 4180;

  const dT = p.water_dT_C;
  const m_dot = Pcoil_W / (cp*dT + 1e-30);
  const Q = m_dot / rho;
  const Q_Lmin = Q*60*1000;

  const D = p.wire_id_mm * 1e-3;
  const Aflow = Math.PI/4 * D*D;

  const Ltotal = d.Lwire_m;
  const n = Math.max(1, nParallel);
  const Lpath = Ltotal / n;
  const Qpath = Q / n;
  const v = Qpath / (Aflow + 1e-30);

  const Re = rho*v*D/(mu + 1e-30);
  const f = frictionFactor(Re);

  const dp_fric = f * (Lpath/(D + 1e-30)) * (rho*v*v/2);
  const dp_minor = p.minor_K * (rho*v*v/2);
  const dp = dp_fric + dp_minor;

  return {Q_Lmin, v_mps:v, Re, f, dp_bar:dp/1e5};
}
function recommendParallel(p, d, Pcoil_W){
  const Nmax = Math.max(1, p.n_parallel_max);
  for (let n=1; n<=Nmax; n++){
    const r = coolingForOneCoil(p, d, Pcoil_W, n);
    if (r.dp_bar <= p.dp_max_bar + 1e-12 && r.v_mps <= p.v_max + 1e-12){
      return {n, r};
    }
  }
  const r = coolingForOneCoil(p, d, Pcoil_W, Nmax);
  return {n:Nmax, r};
}

/** ===================== Plotly layouts ===================== */
function layout3d(){
  return {
    margin:{l:0,r:0,t:0,b:0},
    scene:{
      xaxis:{title:"x (mm)", gridcolor:"rgba(255,255,255,.10)", zerolinecolor:"rgba(255,255,255,.15)"},
      yaxis:{title:"y (mm)", gridcolor:"rgba(255,255,255,.10)", zerolinecolor:"rgba(255,255,255,.15)"},
      zaxis:{title:"z (mm)", gridcolor:"rgba(255,255,255,.10)", zerolinecolor:"rgba(255,255,255,.15)"},
      aspectmode:"data",
      bgcolor:"rgba(0,0,0,0)",
      camera: cameraState
    },
    showlegend:false,
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)",
  };
}
function layout2d(titleX, titleY){
  return {
    margin:{l:60,r:20,t:30,b:50},
    xaxis:{title:titleX, gridcolor:"rgba(255,255,255,.10)", zerolinecolor:"rgba(255,255,255,.15)"},
    yaxis:{title:titleY, gridcolor:"rgba(255,255,255,.10)", zerolinecolor:"rgba(255,255,255,.15)"},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)",
    font:{color:"rgba(232,236,255,0.95)"},
  };
}

/** ===================== Core update ===================== */
async function updateAll(forceRebuild=false){
  if (updateInProgress){ updatePending = true; return; }
  updateInProgress = true;
  const btn = el("btn_update");
  btn.disabled = true;

  try{
    updateDerivedUI();
    const {p, d} = readParams();
    const errs = validateParams(p);
    if (errs.length){ setStatus("å‚æ•°é”™è¯¯ï¼š " + errs.join("ï¼› "), "bad"); return; }

    setStatus("æ­£åœ¨è®¡ç®—â€¦");
    await new Promise(r=>setTimeout(r,10));

    const key = JSON.stringify({
      inner:p.inner_radius_mm, nl:p.n_layers, nt:p.turns_per_layer,
      pitch:p.pitch_mm, od:p.wire_od_mm, id:p.wire_id_mm, ins:p.insulation_mm, gapr:p.gap_radial_mm,
      phase:p.layer_phase_deg,
      zmid:p.coil_mid_z_mm, d:p.coil_spacing_mm,
      seg:p.seg_per_turn_field, vis:p.pts_per_turn_vis,
      I1:p.current1_A, I2:p.current2_A,
      tube:p.tube_sides
    });

    if (forceRebuild || cache.lastParamsKey !== key){
      cache.lastParamsKey = key;
      const zmid = p.coil_mid_z_mm * 1e-3;
      const dz = p.coil_spacing_mm * 1e-3;
      const z1 = zmid - 0.5*dz;
      const z2 = zmid + 0.5*dz;

      cache.coil1 = buildSingleCoil(p, z1);
      cache.coil2 = buildSingleCoil(p, z2);
      const comb = combineSegments(cache.coil1, p.current1_A, cache.coil2, p.current2_A);
      cache.segMid_m = comb.segMid_m;
      cache.segDlI_m = comb.segDlI_m;

      cache.slice = null;
      cache.sliceTraceIndex3d = null;
    }

    const rmin_m = Math.max(p.epsilon_m, 0.5*p.wire_od_mm*1e-3);
    const Bfunc = (pt)=>B_at_point_scaled(pt, cache.segMid_m, cache.segDlI_m, p.epsilon_m, rmin_m);

    // center B
    const B0 = Bfunc([0,0,0]);
    const B0mag = Math.sqrt(B0[0]*B0[0]+B0[1]*B0[1]+B0[2]*B0[2]);
    setText("out_B0", fmtB(B0mag, p.field_unit));
    setText("out_Bz0", fmtB(B0[2], p.field_unit));

    // axis max (quick)
    const span_mm = d.L_coil + p.coil_spacing_mm;
    const axisQuick = computeAxisCurve(span_mm*1.2, 181, Bfunc);
    let bBest=-1, zBest=0;
    for (let i=0;i<axisQuick.zmm.length;i++){
      if (axisQuick.bmag_T[i] > bBest){ bBest = axisQuick.bmag_T[i]; zBest = axisQuick.zmm[i]; }
    }
    setText("axis_zmax", fmt(zBest, "mm", 1));
    setText("axis_bmax", fmtB(bBest, p.field_unit));

    // electrical
    const elec = computeResistanceAndPower(p, d);
    setText("out_Ptotal_big", fmt(elec.Ptotal_W, "W", 1));
    setText("out_Rcoil_big", fmt(elec.Rcoil_ohm, "Î©", 4));

    // cooling
    const PcoilAvg = 0.5*(Math.abs(elec.P1_W)+Math.abs(elec.P2_W));
    let rec = {n:1, r:coolingForOneCoil(p, d, PcoilAvg, 1)};
    if (p.auto_parallel){ rec = recommendParallel(p, d, PcoilAvg); }
    setText("out_nrec_big", p.auto_parallel ? String(rec.n) : "ï¼ˆå…³é—­ï¼‰");

    const cool = coolingForOneCoil(p, d, PcoilAvg, rec.n);
    setText("out_Qcoil_big", fmt(cool.Q_Lmin, "L/min", 2));
    setText("out_Qtotal_big", fmt(2*cool.Q_Lmin, "L/min", 2));
    setText("out_dp_big", fmt(cool.dp_bar, "bar", 3));
    setText("out_v_big", fmt(cool.v_mps, "m/s", 2));

    // 3D traces
    const traces3d = [];
    traces3d.push(...makeCoilTraces(p, cache.coil1, "çº¿åœˆ1"));
    traces3d.push(...makeCoilTraces(p, cache.coil2, "çº¿åœˆ2"));

    const radius_m = p.field_radius_mm * 1e-3;
    const length_m = p.field_length_mm * 1e-3;
    const unit = p.field_unit;
    const cTitle = (unit==="G") ? "|B| (G)" : "|B| (T)";

    let cmin=0, cmax=1;

    if (state.fieldMode === "points"){
      const pts = buildCylindricalSamples(radius_m, length_m, p.pts_nz, p.pts_nr, p.pts_nt);
      const fieldRaw = computeFieldOnPoints(pts, Bfunc);

      let Bmax=0; for (const b of fieldRaw.bmag_T) Bmax=Math.max(Bmax,b);
      const minB_T = p.display_min_frac * Bmax;
      const field = (minB_T>0) ? filterByMinB(fieldRaw, minB_T) : fieldRaw;

      const vals = field.bmag_T.map(b => (unit==="G") ? b*1e4 : b);
      ({cmin, cmax} = robustRange(vals, 0.02, 0.98));

      traces3d.push({
        type:"scatter3d",
        mode:"markers",
        name:"ç‚¹äº‘ |B|",
        x: field.xmm, y: field.ymm, z: field.zmm,
        marker:{
          size: p.marker_size,
          color: vals,
          colorscale:"Viridis",
          opacity: 0.92,
          cmin, cmax,
          colorbar:{title:cTitle},
        },
        hovertemplate:`x=%{x:.1f}mm<br>y=%{y:.1f}mm<br>z=%{z:.1f}mm<br>|B|=%{marker.color:.3g} ${unit}<extra></extra>`
      });

      if (state.showDirs){
        const dpts = buildCylindricalSamples(radius_m, length_m, p.dir_nz, p.dir_nr, p.dir_nt);
        const dRaw = computeFieldOnPoints(dpts, Bfunc);
        const dField = (minB_T>0) ? filterByMinB(dRaw, minB_T) : dRaw;
        const dVals = dField.bmag_T.map(b => (unit==="G") ? b*1e4 : b);

        const bins = buildColoredArrowBins(dField, p.dir_len_mm, p.dir_head, dVals, cmin, cmax, 18);
        for (const bin of bins){
          if (bin.x.length===0) continue;
          traces3d.push({
            type:"scatter3d",
            mode:"lines",
            name:"æ–¹å‘",
            x: bin.x, y: bin.y, z: bin.z,
            line:{width:4, color:bin.color},
            hoverinfo:"skip",
          });
        }
      }
    }else{
      const sl = buildStreamlines(p, radius_m, length_m, Bfunc);
      const valueLines = [];
      const allVals = [];
      for (const L of sl.lines){
        const vv = L.bmag_T.map(b => (unit==="G") ? b*1e4 : b);
        valueLines.push(vv);
        for (const v of vv) allVals.push(v);
      }
      ({cmin, cmax} = robustRange(allVals, 0.02, 0.98));
      const minVal = p.display_min_frac * cmax;

      const bins = buildColoredLineBins(sl.lines, valueLines, cmin, cmax, minVal, 22);
      for (const bin of bins){
        if (bin.x.length===0) continue;
        traces3d.push({
          type:"scatter3d",
          mode:"lines",
          name:"ç£åœºçº¿",
          x: bin.x, y: bin.y, z: bin.z,
          line:{width:4, color:bin.color},
          hoverinfo:"skip",
        });
      }
      traces3d.push({
        type:"scatter3d",
        mode:"markers",
        name:"colorbar",
        x:[0,0], y:[0,0], z:[0,0],
        marker:{ size:0.1, opacity:0.0, color:[cmin, cmax], colorscale:"Viridis", cmin, cmax,
          colorbar:{title:cTitle}},
        hoverinfo:"skip",
        showlegend:false,
      });
    }

    // 3D slice overlay
    cache.sliceTraceIndex3d = null;
    if (p.show_slice_plane){
      const uMax_mm = (p.slice_umax_mm > 0) ? p.slice_umax_mm : p.field_radius_mm;
      const sliceKey = JSON.stringify({uMax_mm, L:p.field_length_mm, nu:p.slice_nu, nz:p.slice_nz, key:cache.lastParamsKey});
      if (!cache.slice || cache.slice.key !== sliceKey){
        const base = computeSliceBase(uMax_mm, p.field_length_mm, p.slice_nu, p.slice_nz, Bfunc);
        cache.slice = {key:sliceKey, ...base};
      }
      const xyz = buildSliceSurfaceXYZ(cache.slice.uAxis_m, cache.slice.zAxis_m, p.slice_angle_deg);
      const surfColor = cache.slice.bmag_T_2d.map(row => row.map(b => (unit==="G") ? b*1e4 : b));

      traces3d.push({
        type:"surface",
        name:"æˆªé¢ |B|",
        x: xyz.X,
        y: xyz.Y,
        z: xyz.Z,
        surfacecolor: surfColor,
        colorscale:"Viridis",
        cmin, cmax,
        opacity: p.slice_opacity,
        showscale:false,
        hoverinfo:"skip",
      });
      cache.sliceTraceIndex3d = traces3d.length - 1;
    }

    await Plotly.react("plot3d", traces3d, layout3d(), {responsive:true, displaylogo:false});

    // Slice tab (render only when tab active; avoid hidden render issues)
    if (state.activeTab === "slice"){
      const uMax_mm = (p.slice_umax_mm > 0) ? p.slice_umax_mm : p.field_radius_mm;
      const sliceKey = JSON.stringify({uMax_mm, L:p.field_length_mm, nu:p.slice_nu, nz:p.slice_nz, key:cache.lastParamsKey});
      if (!cache.slice || cache.slice.key !== sliceKey){
        const base = computeSliceBase(uMax_mm, p.field_length_mm, p.slice_nu, p.slice_nz, Bfunc);
        cache.slice = {key:sliceKey, ...base};
      }
      // color range from slice itself (æ›´ç›´è§‚)
      const sliceVals = cache.slice.flat_T.map(b => (unit==="G") ? b*1e4 : b);
      const rr = robustRange(sliceVals, 0.02, 0.98);
      const zmin = rr.cmin, zmax = rr.cmax;

      const zAxis_mm = cache.slice.zAxis_m.map(z=>z*1e3);
      const uAxis_mm = cache.slice.uAxis_m.map(u=>u*1e3);
      const zGrid = cache.slice.bmag_T_2d.map(row => row.map(b => (unit==="G") ? b*1e4 : b));

      await Plotly.react("plotSlice", [{
        type:"heatmap",
        x: uAxis_mm,
        y: zAxis_mm,
        z: zGrid,
        colorscale:"Viridis",
        zmin, zmax,
        colorbar:{title: cTitle},
        hovertemplate:`u=%{x:.1f}mm<br>z=%{y:.1f}mm<br>|B|=%{z:.3g} ${unit}<extra></extra>`
      }], (()=>{
        const L = layout2d("u (mm)", "z (mm)");
        if (p.slice_equal_aspect){
          // Keep unit scaling identical on x/y (mm:mm). Let x-range expand if needed (avoid cropping z-range).
          L.xaxis = {...(L.xaxis||{}), scaleanchor:"y", scaleratio:1, constrain:"range"};
        }
        L.shapes = buildChamberShapes(p);
        return L;
      })(), {responsive:true, displaylogo:false, editable:true, edits:{shapePosition:true}});
      bindSliceEvents();
    }

    // Axis tab
    if (state.activeTab === "axis"){
      const axisSpan = p.field_length_mm;
      const axisCurve = computeAxisCurve(axisSpan, 241, Bfunc);
      const yBz = axisCurve.bz_T.map(b => (unit==="G") ? b*1e4 : b);
      const yBm = axisCurve.bmag_T.map(b => (unit==="G") ? b*1e4 : b);

      await Plotly.react("plotAxis", [
        {type:"scatter", mode:"lines", name:"Bz(z)", x: axisCurve.zmm, y: yBz, line:{width:3, color:"#4ea1ff"}},
        {type:"scatter", mode:"lines", name:"|B|(z)", x: axisCurve.zmm, y: yBm, line:{width:3, color:"#ffb04e"}},
      ], {
        ...layout2d("z (mm)", unit==="G" ? "B (G)" : "B (T)"),
        legend:{orientation:"h", yanchor:"bottom", y:1.02, xanchor:"right", x:1.0},
        title:{text:"è½´çº¿ç£åœºï¼ˆr=0ï¼‰", font:{size:14, color:"rgba(232,236,255,0.95)"}}
      }, {responsive:true, displaylogo:false});
    }

    requestAnimationFrame(()=>resizeActivePlot());

    setStatus(`å®Œæˆã€‚è®¡ç®—åŸŸ R=${p.field_radius_mm.toFixed(0)} mm, L=${p.field_length_mm.toFixed(0)} mmï¼›è½¯åŒ–åŠå¾„â‰ˆ${(rmin_m*1e3).toFixed(2)} mmï¼›é¢œè‰²èŒƒå›´ä½¿ç”¨ç™¾åˆ†ä½ï¼ˆæ›´æ˜“è¯»ï¼‰`, "ok");
  }catch(err){
    console.error(err);
    setStatus("å‘ç”Ÿé”™è¯¯ï¼š" + (err?.message || String(err)), "bad");
  }finally{
    btn.disabled = false;
    updateInProgress = false;
    if (updatePending){ updatePending = false; updateAll(false); }
  }
}

/** ===================== Slice angle: fast update ===================== */
let sliceRotateRAF = null;
function updateSliceAngleOnly(){
  setText("slice_angle_label", String(Math.round(Number(el("slice_angle_deg").value))));
  if (!cache.slice || cache.sliceTraceIndex3d === null) return;
  const angle = Number(el("slice_angle_deg").value);
  const xyz = buildSliceSurfaceXYZ(cache.slice.uAxis_m, cache.slice.zAxis_m, angle);
  Plotly.restyle("plot3d", {x:[xyz.X], y:[xyz.Y]}, [cache.sliceTraceIndex3d]);
}

/** ===================== Tabs & resize ===================== */
function setActiveTab(tab){
  state.activeTab = tab;
  document.querySelectorAll(".tab").forEach(t=>t.classList.toggle("active", t.dataset.tab === tab));

  ["plot3d","plotSlice","plotAxis"].forEach(id=>el(id).classList.remove("active"));
  if (tab === "3d") el("plot3d").classList.add("active");
  if (tab === "slice") el("plotSlice").classList.add("active");
  if (tab === "axis") el("plotAxis").classList.add("active");

  updateAll(false);
  setTimeout(()=>resizeActivePlot(), 80);
}
function resizeActivePlot(){
  try{
    if (state.activeTab === "3d") Plotly.Plots.resize(el("plot3d"));
    if (state.activeTab === "slice") Plotly.Plots.resize(el("plotSlice"));
    if (state.activeTab === "axis") Plotly.Plots.resize(el("plotAxis"));
  }catch(e){}
}
document.querySelectorAll(".tab").forEach(t=>{
  t.addEventListener("click", ()=>setActiveTab(t.dataset.tab));
});

/** ===================== Buttons ===================== */
el("btn_update").addEventListener("click", ()=>updateAll(true));
el("btn_toggle_field_mode").addEventListener("click", ()=>{
  state.fieldMode = (state.fieldMode === "points") ? "lines" : "points";
  if (state.fieldMode === "lines") state.showDirs = false;
  updateDerivedUI();
  updateAll(false);
});
el("btn_toggle_dirs").addEventListener("click", ()=>{
  state.showDirs = !state.showDirs;
  updateAll(false);
});
el("btn_cam_flat").addEventListener("click", ()=>setCameraPreset(CAM_FLAT));
el("btn_cam_std").addEventListener("click", ()=>setCameraPreset(CAM_STD));

el("btn_reset").addEventListener("click", ()=>{
  const defaults = {
    coil_spacing_mm:300, coil_mid_z_mm:0, coil_mode:"helmholtz",
    current1_A:200, current2_A:200,
    inner_radius_mm:150, n_layers:5, turns_per_layer:10,
    wire_od_mm:8, wire_id_mm:6, insulation_mm:0.2, gap_radial_mm:0.2,
    auto_pitch:"on", gap_axial_mm:0.0, pitch_mm:8.4,
    quality_preset:"standard",
    water_dT_C:10, dp_max_bar:1.0, v_max:2.5, n_parallel_max:12, auto_parallel:true,
    field_unit:"G", display_min_frac:0,
    auto_domain:"on", domain_margin_r_mm:30, domain_margin_z_mm:300,
    slice_opacity:0.35, show_slice_plane:true, slice_angle_deg:0,
    slice_equal_aspect:true, show_chamber_lines:true, chamber_radius_mm:60,
    elec_wiring:"separate", minor_K:3,
    temp_cu_C:40, extra_lead_m:0.5, rho20:"1.68e-8", alpha_cu:0.00393,
    show_tube_sel:"on", show_hollow_sel:"on", show_insulation_shell:"on", layer_phase_deg:0,
    marker_size:3, dir_len_mm:10, dir_head:true,
    field_radius_mm:260, field_length_mm:1600,
    slice_nu:81, slice_nz:121, slice_umax_mm:0,
    pts_nz:23, pts_nr:7, pts_nt:14,
    dir_nz:12, dir_nr:4, dir_nt:10,
    pts_per_turn_vis:16, seg_per_turn_field:35, tube_sides:12, epsilon_m:"1e-6",
    seed_z_mm:0, seed_r_max_frac:0.6, seed_nr:6, seed_nt:12, line_step_mm:10, line_max_steps:200,
  };
  for (const [k,v] of Object.entries(defaults)){
    const e = el(k);
    if (!e) continue;
    if (e.type === "checkbox") e.checked = !!v;
    else e.value = v;
  }
  state.fieldMode = "points";
  state.showDirs = true;
  cache.lastParamsKey = null;
  cache.slice = null;
  cache.sliceTraceIndex3d = null;
  cameraState = {...CAM_STD};
  updateDerivedUI();
  updateAll(true);
});

/** ===================== Inputs ===================== */
function attach(id){
  const e = el(id);
  if (!e) return;
  e.addEventListener("input", ()=>updateDerivedUI());
  e.addEventListener("change", ()=>updateDerivedUI());
}
[
  "coil_spacing_mm","coil_mid_z_mm","coil_mode","current1_A","current2_A",
  "inner_radius_mm","n_layers","turns_per_layer","wire_od_mm","wire_id_mm","insulation_mm","gap_radial_mm",
  "auto_pitch","gap_axial_mm","pitch_mm","quality_preset",
  "water_dT_C","dp_max_bar","v_max","n_parallel_max","auto_parallel",
  "field_unit","display_min_frac","auto_domain","domain_margin_r_mm","domain_margin_z_mm",
  "slice_opacity","show_slice_plane","slice_equal_aspect","show_chamber_lines","chamber_radius_mm",
  "show_tube_sel","show_hollow_sel","show_insulation_shell","layer_phase_deg",
  "marker_size","dir_len_mm","dir_head",
  "field_radius_mm","field_length_mm",
  "slice_nu","slice_nz","slice_umax_mm",
  "pts_nz","pts_nr","pts_nt","dir_nz","dir_nr","dir_nt",
  "pts_per_turn_vis","seg_per_turn_field","tube_sides","epsilon_m",
  "seed_z_mm","seed_r_max_frac","seed_nr","seed_nt","line_step_mm","line_max_steps",
  "elec_wiring","minor_K","temp_cu_C","extra_lead_m","rho20","alpha_cu"
].forEach(attach);

function bindSliceOverlayControls(){
  const ids = ["slice_equal_aspect","show_chamber_lines","chamber_radius_mm"];
  const handler = ()=>{
    if (state.activeTab !== "slice") return;
    const {p} = readParams();

    const rel = {"shapes": buildChamberShapes(p)};
    if (p.slice_equal_aspect){
      rel["xaxis.scaleanchor"] = "y";
      rel["xaxis.scaleratio"] = 1;
      rel["xaxis.constrain"] = "range";
    }else{
      rel["xaxis.scaleanchor"] = null;
      rel["xaxis.scaleratio"] = null;
      rel["xaxis.constrain"] = null;
    }
    Plotly.relayout("plotSlice", rel).catch(()=>{});
  };

  for (const id of ids){
    const e = el(id);
    if (!e) continue;
    e.addEventListener("input", handler);
    e.addEventListener("change", handler);
  }
}

function bindAutoUpdateForDomain(){
  const ids = ["auto_domain","domain_margin_r_mm","domain_margin_z_mm","field_radius_mm","field_length_mm"];
  const handler = ()=>scheduleUpdate(380, false);
  for (const id of ids){
    const e = el(id);
    if (!e) continue;
    e.addEventListener("input", handler);
    e.addEventListener("change", handler);
  }
}

bindSliceOverlayControls();
bindAutoUpdateForDomain();


el("slice_angle_deg").addEventListener("input", ()=>{
  if (sliceRotateRAF) cancelAnimationFrame(sliceRotateRAF);
  sliceRotateRAF = requestAnimationFrame(()=>updateSliceAngleOnly());
});
el("slice_angle_deg").addEventListener("change", ()=>updateSliceAngleOnly());

/** ===================== Init ===================== */
updateDerivedUI();
updateAll(true);
setTimeout(()=>bindCameraPersistence(), 200);
</script>
</body>
</html>
